#include "zebu.h"

#ifndef ZEBU_LINE_NUMBERS
#define ZEBU_LINE_NUMBERS (0)
#endif

#ifndef ZEBU_COLUMN_NUMBERS
#define ZEBU_COLUMN_NUMBERS (0)
#endif

#ifndef ZEBU_TREE_DEPTH
#define ZEBU_TREE_DEPTH (0)
#endif

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[197][32] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[3][2] = 13,
	[3][3] = 14,
	[3][4] = 15,
	[3][5] = 16,
	[5][2] = 22,
	[5][3] = 23,
	[5][11] = 24,
	[6][10] = 31,
	[7][6] = 32,
	[8][7] = 33,
	[8][8] = 34,
	[8][9] = 35,
	[9][2] = 2,
	[9][3] = 3,
	[9][4] = 4,
	[9][5] = 5,
	[12][2] = 2,
	[12][3] = 3,
	[12][4] = 4,
	[12][5] = 5,
	[14][2] = 13,
	[14][3] = 14,
	[14][4] = 15,
	[14][5] = 16,
	[16][2] = 22,
	[16][3] = 23,
	[16][11] = 24,
	[17][13] = 41,
	[18][6] = 42,
	[19][7] = 43,
	[19][8] = 44,
	[19][9] = 45,
	[20][2] = 13,
	[20][3] = 14,
	[20][4] = 15,
	[20][5] = 16,
	[23][2] = 47,
	[23][3] = 48,
	[23][11] = 49,
	[24][2] = 22,
	[24][3] = 23,
	[25][16] = 57,
	[27][6] = 58,
	[28][14] = 59,
	[29][15] = 60,
	[31][17] = 61,
	[32][2] = 2,
	[32][3] = 3,
	[32][4] = 4,
	[32][5] = 5,
	[38][2] = 2,
	[38][3] = 3,
	[38][4] = 4,
	[38][5] = 5,
	[39][13] = 64,
	[40][16] = 65,
	[42][2] = 13,
	[42][3] = 14,
	[42][4] = 15,
	[42][5] = 16,
	[48][2] = 47,
	[48][3] = 48,
	[48][11] = 49,
	[49][2] = 47,
	[49][3] = 48,
	[50][13] = 69,
	[52][6] = 70,
	[53][14] = 71,
	[54][15] = 72,
	[58][2] = 22,
	[58][3] = 23,
	[58][11] = 24,
	[59][2] = 74,
	[59][3] = 75,
	[59][11] = 76,
	[60][2] = 22,
	[60][3] = 23,
	[60][11] = 24,
	[61][18] = 80,
	[61][19] = 81,
	[61][20] = 82,
	[61][21] = 83,
	[61][22] = 84,
	[61][23] = 85,
	[67][13] = 88,
	[70][2] = 47,
	[70][3] = 48,
	[70][11] = 49,
	[71][2] = 90,
	[71][3] = 91,
	[71][11] = 92,
	[72][2] = 47,
	[72][3] = 48,
	[72][11] = 49,
	[75][2] = 47,
	[75][3] = 48,
	[75][11] = 49,
	[76][2] = 74,
	[76][3] = 75,
	[80][3] = 98,
	[80][24] = 99,
	[80][25] = 100,
	[80][26] = 101,
	[80][27] = 102,
	[81][10] = 104,
	[82][10] = 106,
	[83][10] = 108,
	[84][10] = 110,
	[85][28] = 112,
	[87][18] = 80,
	[87][19] = 114,
	[87][20] = 115,
	[87][21] = 116,
	[87][22] = 117,
	[87][23] = 119,
	[87][29] = 118,
	[91][2] = 47,
	[91][3] = 48,
	[91][11] = 49,
	[92][2] = 90,
	[92][3] = 91,
	[96][13] = 124,
	[98][3] = 125,
	[98][9] = 127,
	[98][14] = 126,
	[98][24] = 128,
	[98][25] = 129,
	[98][26] = 130,
	[98][27] = 131,
	[103][10] = 138,
	[103][30] = 137,
	[104][3] = 139,
	[104][9] = 141,
	[104][14] = 140,
	[104][24] = 142,
	[104][25] = 143,
	[104][26] = 144,
	[104][27] = 145,
	[106][3] = 139,
	[106][9] = 141,
	[106][14] = 140,
	[106][24] = 142,
	[106][25] = 143,
	[106][26] = 144,
	[106][27] = 145,
	[108][3] = 139,
	[108][9] = 141,
	[108][14] = 140,
	[108][24] = 142,
	[108][25] = 143,
	[108][26] = 144,
	[108][27] = 145,
	[110][3] = 139,
	[110][9] = 141,
	[110][14] = 140,
	[110][24] = 142,
	[110][25] = 143,
	[110][26] = 144,
	[110][27] = 145,
	[114][10] = 104,
	[115][10] = 106,
	[116][10] = 108,
	[117][10] = 110,
	[118][18] = 80,
	[118][19] = 81,
	[118][20] = 82,
	[118][21] = 83,
	[118][22] = 84,
	[118][23] = 85,
	[119][28] = 112,
	[121][18] = 80,
	[121][19] = 114,
	[121][20] = 115,
	[121][21] = 116,
	[121][22] = 117,
	[121][23] = 119,
	[121][29] = 118,
	[122][13] = 161,
	[125][3] = 125,
	[125][9] = 127,
	[125][14] = 126,
	[125][24] = 128,
	[125][25] = 129,
	[125][26] = 130,
	[125][27] = 131,
	[126][3] = 125,
	[126][24] = 128,
	[126][25] = 129,
	[126][26] = 130,
	[126][27] = 131,
	[127][3] = 125,
	[127][24] = 128,
	[127][25] = 129,
	[127][26] = 130,
	[127][27] = 131,
	[132][13] = 166,
	[133][9] = 168,
	[133][14] = 167,
	[135][8] = 169,
	[135][31] = 170,
	[137][10] = 171,
	[138][3] = 139,
	[138][9] = 141,
	[138][14] = 140,
	[138][24] = 142,
	[138][25] = 143,
	[138][26] = 144,
	[138][27] = 145,
	[139][3] = 125,
	[139][9] = 127,
	[139][14] = 126,
	[139][24] = 128,
	[139][25] = 129,
	[139][26] = 130,
	[139][27] = 131,
	[140][3] = 139,
	[140][24] = 142,
	[140][25] = 143,
	[140][26] = 144,
	[140][27] = 145,
	[141][3] = 139,
	[141][24] = 142,
	[141][25] = 143,
	[141][26] = 144,
	[141][27] = 145,
	[146][18] = 80,
	[146][19] = 114,
	[146][20] = 115,
	[146][21] = 116,
	[146][22] = 117,
	[146][23] = 119,
	[146][29] = 118,
	[147][9] = 180,
	[147][14] = 179,
	[149][8] = 181,
	[149][31] = 182,
	[151][18] = 80,
	[151][19] = 114,
	[151][20] = 115,
	[151][21] = 116,
	[151][22] = 117,
	[151][23] = 119,
	[151][29] = 118,
	[152][18] = 80,
	[152][19] = 114,
	[152][20] = 115,
	[152][21] = 116,
	[152][22] = 117,
	[152][23] = 119,
	[152][29] = 118,
	[153][18] = 80,
	[153][19] = 114,
	[153][20] = 115,
	[153][21] = 116,
	[153][22] = 117,
	[153][23] = 119,
	[153][29] = 118,
	[162][13] = 186,
	[167][3] = 125,
	[167][9] = 127,
	[167][14] = 126,
	[167][24] = 128,
	[167][25] = 129,
	[167][26] = 130,
	[167][27] = 131,
	[168][3] = 125,
	[168][9] = 127,
	[168][14] = 126,
	[168][24] = 128,
	[168][25] = 129,
	[168][26] = 130,
	[168][27] = 131,
	[169][3] = 125,
	[169][9] = 127,
	[169][14] = 126,
	[169][24] = 128,
	[169][25] = 129,
	[169][26] = 130,
	[169][27] = 131,
	[170][3] = 125,
	[170][9] = 127,
	[170][14] = 126,
	[170][24] = 128,
	[170][25] = 129,
	[170][26] = 130,
	[170][27] = 131,
	[171][3] = 139,
	[171][9] = 141,
	[171][14] = 140,
	[171][24] = 142,
	[171][25] = 143,
	[171][26] = 144,
	[171][27] = 145,
	[174][13] = 194,
	[179][3] = 139,
	[179][9] = 141,
	[179][14] = 140,
	[179][24] = 142,
	[179][25] = 143,
	[179][26] = 144,
	[179][27] = 145,
	[180][3] = 139,
	[180][9] = 141,
	[180][14] = 140,
	[180][24] = 142,
	[180][25] = 143,
	[180][26] = 144,
	[180][27] = 145,
	[181][3] = 139,
	[181][9] = 141,
	[181][14] = 140,
	[181][24] = 142,
	[181][25] = 143,
	[181][26] = 144,
	[181][27] = 145,
	[182][3] = 139,
	[182][9] = 141,
	[182][14] = 140,
	[182][24] = 142,
	[182][25] = 143,
	[182][26] = 144,
	[182][27] = 145,
	[188][8] = 169,
	[188][31] = 170,
	[196][8] = 181,
	[196][31] = 182,
};


const unsigned zebu_reduces[201][32] = {
	[2][2] = 1,
	[2][3] = 1,
	[2][4] = 1,
	[2][5] = 1,
	[2][6] = 1,
	[2][7] = 1,
	[2][8] = 1,
	[2][9] = 1,
	[2][10] = 1,
	[4][2] = 2,
	[4][3] = 2,
	[4][4] = 2,
	[4][5] = 2,
	[4][6] = 2,
	[4][7] = 2,
	[4][8] = 2,
	[4][9] = 2,
	[4][10] = 2,
	[7][10] = 3,
	[8][2] = 4,
	[8][3] = 4,
	[8][4] = 4,
	[8][5] = 4,
	[8][6] = 4,
	[8][10] = 4,
	[9][6] = 5,
	[9][10] = 5,
	[10][10] = 6,
	[11][12] = 7,
	[12][12] = 8,
	[13][2] = 1,
	[13][3] = 1,
	[13][4] = 1,
	[13][5] = 1,
	[13][6] = 1,
	[13][7] = 1,
	[13][8] = 1,
	[13][9] = 1,
	[13][13] = 1,
	[15][2] = 2,
	[15][3] = 2,
	[15][4] = 2,
	[15][5] = 2,
	[15][6] = 2,
	[15][7] = 2,
	[15][8] = 2,
	[15][9] = 2,
	[15][13] = 2,
	[18][13] = 3,
	[19][2] = 4,
	[19][3] = 4,
	[19][4] = 4,
	[19][5] = 4,
	[19][6] = 4,
	[19][13] = 4,
	[20][6] = 5,
	[20][13] = 5,
	[21][13] = 6,
	[22][6] = 9,
	[22][14] = 9,
	[22][15] = 9,
	[22][16] = 9,
	[26][6] = 10,
	[26][14] = 10,
	[26][15] = 10,
	[26][16] = 10,
	[27][16] = 11,
	[28][6] = 12,
	[28][15] = 12,
	[28][16] = 12,
	[29][6] = 13,
	[29][16] = 13,
	[30][16] = 14,
	[33][2] = 15,
	[33][3] = 15,
	[33][4] = 15,
	[33][5] = 15,
	[33][6] = 15,
	[33][10] = 15,
	[34][2] = 16,
	[34][3] = 16,
	[34][4] = 16,
	[34][5] = 16,
	[34][6] = 16,
	[34][10] = 16,
	[35][2] = 17,
	[35][3] = 17,
	[35][4] = 17,
	[35][5] = 17,
	[35][6] = 17,
	[35][10] = 17,
	[36][6] = 18,
	[36][10] = 18,
	[37][12] = 19,
	[38][12] = 20,
	[41][2] = 21,
	[41][3] = 21,
	[41][4] = 21,
	[41][5] = 21,
	[41][6] = 21,
	[41][7] = 21,
	[41][8] = 21,
	[41][9] = 21,
	[41][10] = 21,
	[43][2] = 15,
	[43][3] = 15,
	[43][4] = 15,
	[43][5] = 15,
	[43][6] = 15,
	[43][13] = 15,
	[44][2] = 16,
	[44][3] = 16,
	[44][4] = 16,
	[44][5] = 16,
	[44][6] = 16,
	[44][13] = 16,
	[45][2] = 17,
	[45][3] = 17,
	[45][4] = 17,
	[45][5] = 17,
	[45][6] = 17,
	[45][13] = 17,
	[46][6] = 18,
	[46][13] = 18,
	[47][6] = 9,
	[47][13] = 9,
	[47][14] = 9,
	[47][15] = 9,
	[51][6] = 10,
	[51][13] = 10,
	[51][14] = 10,
	[51][15] = 10,
	[52][13] = 11,
	[53][6] = 12,
	[53][13] = 12,
	[53][15] = 12,
	[54][6] = 13,
	[54][13] = 13,
	[55][13] = 14,
	[56][6] = 22,
	[56][14] = 22,
	[56][15] = 22,
	[56][16] = 22,
	[57][2] = 23,
	[57][3] = 23,
	[57][4] = 23,
	[57][5] = 23,
	[57][6] = 23,
	[57][7] = 23,
	[57][8] = 23,
	[57][9] = 23,
	[57][10] = 23,
	[62][10] = 24,
	[63][12] = 25,
	[64][2] = 21,
	[64][3] = 21,
	[64][4] = 21,
	[64][5] = 21,
	[64][6] = 21,
	[64][7] = 21,
	[64][8] = 21,
	[64][9] = 21,
	[64][13] = 21,
	[65][2] = 23,
	[65][3] = 23,
	[65][4] = 23,
	[65][5] = 23,
	[65][6] = 23,
	[65][7] = 23,
	[65][8] = 23,
	[65][9] = 23,
	[65][13] = 23,
	[66][13] = 24,
	[68][6] = 22,
	[68][13] = 22,
	[68][14] = 22,
	[68][15] = 22,
	[69][6] = 26,
	[69][14] = 26,
	[69][15] = 26,
	[69][16] = 26,
	[73][16] = 27,
	[74][6] = 9,
	[74][15] = 9,
	[74][16] = 9,
	[77][6] = 10,
	[77][15] = 10,
	[77][16] = 10,
	[78][6] = 28,
	[78][15] = 28,
	[78][16] = 28,
	[79][6] = 29,
	[79][16] = 29,
	[86][2] = 30,
	[86][3] = 30,
	[86][4] = 30,
	[86][5] = 30,
	[86][12] = 30,
	[88][6] = 26,
	[88][13] = 26,
	[88][14] = 26,
	[88][15] = 26,
	[89][13] = 27,
	[90][6] = 9,
	[90][13] = 9,
	[90][15] = 9,
	[93][6] = 10,
	[93][13] = 10,
	[93][15] = 10,
	[94][6] = 28,
	[94][13] = 28,
	[94][15] = 28,
	[95][6] = 29,
	[95][13] = 29,
	[97][6] = 22,
	[97][15] = 22,
	[97][16] = 22,
	[99][10] = 31,
	[99][30] = 31,
	[100][10] = 32,
	[100][30] = 32,
	[101][10] = 33,
	[101][30] = 33,
	[102][10] = 34,
	[102][30] = 34,
	[105][2] = 35,
	[105][3] = 35,
	[105][4] = 35,
	[105][5] = 35,
	[105][12] = 35,
	[107][2] = 36,
	[107][3] = 36,
	[107][4] = 36,
	[107][5] = 36,
	[107][12] = 36,
	[109][2] = 37,
	[109][3] = 37,
	[109][4] = 37,
	[109][5] = 37,
	[109][12] = 37,
	[111][2] = 38,
	[111][3] = 38,
	[111][4] = 38,
	[111][5] = 38,
	[111][12] = 38,
	[112][2] = 39,
	[112][3] = 39,
	[112][4] = 39,
	[112][5] = 39,
	[112][12] = 39,
	[113][2] = 40,
	[113][3] = 40,
	[113][4] = 40,
	[113][5] = 40,
	[113][12] = 40,
	[120][2] = 41,
	[120][3] = 41,
	[120][4] = 41,
	[120][5] = 41,
	[120][12] = 41,
	[123][6] = 22,
	[123][13] = 22,
	[123][15] = 22,
	[124][6] = 26,
	[124][15] = 26,
	[124][16] = 26,
	[128][8] = 31,
	[128][9] = 31,
	[128][13] = 31,
	[128][14] = 31,
	[128][31] = 31,
	[129][8] = 32,
	[129][9] = 32,
	[129][13] = 32,
	[129][14] = 32,
	[129][31] = 32,
	[130][8] = 33,
	[130][9] = 33,
	[130][13] = 33,
	[130][14] = 33,
	[130][31] = 33,
	[131][8] = 34,
	[131][9] = 34,
	[131][13] = 34,
	[131][14] = 34,
	[131][31] = 34,
	[133][13] = 42,
	[134][8] = 43,
	[134][9] = 43,
	[134][13] = 43,
	[134][14] = 43,
	[134][31] = 43,
	[135][9] = 44,
	[135][13] = 44,
	[135][14] = 44,
	[136][8] = 45,
	[136][9] = 45,
	[136][13] = 45,
	[136][14] = 45,
	[136][31] = 45,
	[142][8] = 31,
	[142][9] = 31,
	[142][14] = 31,
	[142][18] = 31,
	[142][19] = 31,
	[142][20] = 31,
	[142][21] = 31,
	[142][22] = 31,
	[142][23] = 31,
	[142][29] = 31,
	[142][31] = 31,
	[143][8] = 32,
	[143][9] = 32,
	[143][14] = 32,
	[143][18] = 32,
	[143][19] = 32,
	[143][20] = 32,
	[143][21] = 32,
	[143][22] = 32,
	[143][23] = 32,
	[143][29] = 32,
	[143][31] = 32,
	[144][8] = 33,
	[144][9] = 33,
	[144][14] = 33,
	[144][18] = 33,
	[144][19] = 33,
	[144][20] = 33,
	[144][21] = 33,
	[144][22] = 33,
	[144][23] = 33,
	[144][29] = 33,
	[144][31] = 33,
	[145][8] = 34,
	[145][9] = 34,
	[145][14] = 34,
	[145][18] = 34,
	[145][19] = 34,
	[145][20] = 34,
	[145][21] = 34,
	[145][22] = 34,
	[145][23] = 34,
	[145][29] = 34,
	[145][31] = 34,
	[147][18] = 42,
	[147][19] = 42,
	[147][20] = 42,
	[147][21] = 42,
	[147][22] = 42,
	[147][23] = 42,
	[147][29] = 42,
	[148][8] = 43,
	[148][9] = 43,
	[148][14] = 43,
	[148][18] = 43,
	[148][19] = 43,
	[148][20] = 43,
	[148][21] = 43,
	[148][22] = 43,
	[148][23] = 43,
	[148][29] = 43,
	[148][31] = 43,
	[149][9] = 44,
	[149][14] = 44,
	[149][18] = 44,
	[149][19] = 44,
	[149][20] = 44,
	[149][21] = 44,
	[149][22] = 44,
	[149][23] = 44,
	[149][29] = 44,
	[150][8] = 45,
	[150][9] = 45,
	[150][14] = 45,
	[150][18] = 45,
	[150][19] = 45,
	[150][20] = 45,
	[150][21] = 45,
	[150][22] = 45,
	[150][23] = 45,
	[150][29] = 45,
	[150][31] = 45,
	[154][2] = 46,
	[154][3] = 46,
	[154][4] = 46,
	[154][5] = 46,
	[154][12] = 46,
	[155][2] = 47,
	[155][3] = 47,
	[155][4] = 47,
	[155][5] = 47,
	[155][12] = 47,
	[156][2] = 48,
	[156][3] = 48,
	[156][4] = 48,
	[156][5] = 48,
	[156][12] = 48,
	[157][2] = 49,
	[157][3] = 49,
	[157][4] = 49,
	[157][5] = 49,
	[157][12] = 49,
	[158][2] = 50,
	[158][3] = 50,
	[158][4] = 50,
	[158][5] = 50,
	[158][12] = 50,
	[159][2] = 51,
	[159][3] = 51,
	[159][4] = 51,
	[159][5] = 51,
	[159][12] = 51,
	[160][2] = 52,
	[160][3] = 52,
	[160][4] = 52,
	[160][5] = 52,
	[160][12] = 52,
	[161][6] = 26,
	[161][13] = 26,
	[161][15] = 26,
	[163][8] = 53,
	[163][9] = 53,
	[163][13] = 53,
	[163][14] = 53,
	[163][31] = 53,
	[164][8] = 54,
	[164][9] = 54,
	[164][13] = 54,
	[164][14] = 54,
	[164][31] = 54,
	[165][8] = 55,
	[165][9] = 55,
	[165][13] = 55,
	[165][14] = 55,
	[165][31] = 55,
	[166][10] = 56,
	[166][30] = 56,
	[172][18] = 57,
	[172][19] = 57,
	[172][20] = 57,
	[172][21] = 57,
	[172][22] = 57,
	[172][23] = 57,
	[172][29] = 57,
	[173][18] = 58,
	[173][19] = 58,
	[173][20] = 58,
	[173][21] = 58,
	[173][22] = 58,
	[173][23] = 58,
	[173][29] = 58,
	[175][8] = 53,
	[175][9] = 53,
	[175][14] = 53,
	[175][18] = 53,
	[175][19] = 53,
	[175][20] = 53,
	[175][21] = 53,
	[175][22] = 53,
	[175][23] = 53,
	[175][29] = 53,
	[175][31] = 53,
	[176][8] = 54,
	[176][9] = 54,
	[176][14] = 54,
	[176][18] = 54,
	[176][19] = 54,
	[176][20] = 54,
	[176][21] = 54,
	[176][22] = 54,
	[176][23] = 54,
	[176][29] = 54,
	[176][31] = 54,
	[177][8] = 55,
	[177][9] = 55,
	[177][14] = 55,
	[177][18] = 55,
	[177][19] = 55,
	[177][20] = 55,
	[177][21] = 55,
	[177][22] = 55,
	[177][23] = 55,
	[177][29] = 55,
	[177][31] = 55,
	[178][2] = 59,
	[178][3] = 59,
	[178][4] = 59,
	[178][5] = 59,
	[178][12] = 59,
	[183][2] = 60,
	[183][3] = 60,
	[183][4] = 60,
	[183][5] = 60,
	[183][12] = 60,
	[184][2] = 61,
	[184][3] = 61,
	[184][4] = 61,
	[184][5] = 61,
	[184][12] = 61,
	[185][2] = 62,
	[185][3] = 62,
	[185][4] = 62,
	[185][5] = 62,
	[185][12] = 62,
	[186][8] = 56,
	[186][9] = 56,
	[186][13] = 56,
	[186][14] = 56,
	[186][31] = 56,
	[187][9] = 63,
	[187][13] = 63,
	[187][14] = 63,
	[188][9] = 64,
	[188][13] = 64,
	[188][14] = 64,
	[189][9] = 65,
	[189][13] = 65,
	[189][14] = 65,
	[190][8] = 66,
	[190][9] = 66,
	[190][13] = 66,
	[190][14] = 66,
	[190][31] = 66,
	[191][8] = 67,
	[191][9] = 67,
	[191][13] = 67,
	[191][14] = 67,
	[191][31] = 67,
	[192][8] = 68,
	[192][9] = 68,
	[192][13] = 68,
	[192][14] = 68,
	[192][31] = 68,
	[193][18] = 69,
	[193][19] = 69,
	[193][20] = 69,
	[193][21] = 69,
	[193][22] = 69,
	[193][23] = 69,
	[193][29] = 69,
	[194][8] = 56,
	[194][9] = 56,
	[194][14] = 56,
	[194][18] = 56,
	[194][19] = 56,
	[194][20] = 56,
	[194][21] = 56,
	[194][22] = 56,
	[194][23] = 56,
	[194][29] = 56,
	[194][31] = 56,
	[195][9] = 63,
	[195][14] = 63,
	[195][18] = 63,
	[195][19] = 63,
	[195][20] = 63,
	[195][21] = 63,
	[195][22] = 63,
	[195][23] = 63,
	[195][29] = 63,
	[196][9] = 64,
	[196][14] = 64,
	[196][18] = 64,
	[196][19] = 64,
	[196][20] = 64,
	[196][21] = 64,
	[196][22] = 64,
	[196][23] = 64,
	[196][29] = 64,
	[197][9] = 65,
	[197][14] = 65,
	[197][18] = 65,
	[197][19] = 65,
	[197][20] = 65,
	[197][21] = 65,
	[197][22] = 65,
	[197][23] = 65,
	[197][29] = 65,
	[198][8] = 66,
	[198][9] = 66,
	[198][14] = 66,
	[198][18] = 66,
	[198][19] = 66,
	[198][20] = 66,
	[198][21] = 66,
	[198][22] = 66,
	[198][23] = 66,
	[198][29] = 66,
	[198][31] = 66,
	[199][8] = 67,
	[199][9] = 67,
	[199][14] = 67,
	[199][18] = 67,
	[199][19] = 67,
	[199][20] = 67,
	[199][21] = 67,
	[199][22] = 67,
	[199][23] = 67,
	[199][29] = 67,
	[199][31] = 67,
	[200][8] = 68,
	[200][9] = 68,
	[200][14] = 68,
	[200][18] = 68,
	[200][19] = 68,
	[200][20] = 68,
	[200][21] = 68,
	[200][22] = 68,
	[200][23] = 68,
	[200][29] = 68,
	[200][31] = 68,
};


const unsigned zebu_gotos[183][32] = {
	[1][1] = 6,
	[1][2] = 7,
	[1][3] = 8,
	[1][4] = 9,
	[1][5] = 10,
	[1][6] = 11,
	[1][7] = 12,
	[3][1] = 17,
	[3][2] = 18,
	[3][3] = 19,
	[3][4] = 20,
	[3][5] = 21,
	[5][8] = 25,
	[5][9] = 26,
	[5][10] = 27,
	[5][11] = 28,
	[5][12] = 29,
	[5][13] = 30,
	[9][2] = 36,
	[9][3] = 8,
	[9][4] = 9,
	[12][1] = 6,
	[12][2] = 7,
	[12][3] = 8,
	[12][4] = 9,
	[12][5] = 10,
	[12][7] = 38,
	[12][14] = 37,
	[14][1] = 39,
	[14][2] = 18,
	[14][3] = 19,
	[14][4] = 20,
	[14][5] = 21,
	[16][8] = 40,
	[16][9] = 26,
	[16][10] = 27,
	[16][11] = 28,
	[16][12] = 29,
	[16][13] = 30,
	[20][2] = 46,
	[20][3] = 19,
	[20][4] = 20,
	[23][8] = 50,
	[23][9] = 51,
	[23][10] = 52,
	[23][11] = 53,
	[23][12] = 54,
	[23][13] = 55,
	[24][9] = 56,
	[32][2] = 7,
	[32][3] = 8,
	[32][4] = 9,
	[32][5] = 62,
	[38][1] = 6,
	[38][2] = 7,
	[38][3] = 8,
	[38][4] = 9,
	[38][5] = 10,
	[38][7] = 38,
	[38][14] = 63,
	[42][2] = 18,
	[42][3] = 19,
	[42][4] = 20,
	[42][5] = 66,
	[48][8] = 67,
	[48][9] = 51,
	[48][10] = 52,
	[48][11] = 53,
	[48][12] = 54,
	[48][13] = 55,
	[49][9] = 68,
	[58][9] = 26,
	[58][10] = 27,
	[58][11] = 28,
	[58][12] = 29,
	[58][13] = 73,
	[59][9] = 77,
	[59][11] = 78,
	[60][9] = 26,
	[60][10] = 79,
	[60][11] = 28,
	[60][12] = 29,
	[61][15] = 86,
	[61][16] = 87,
	[70][9] = 51,
	[70][10] = 52,
	[70][11] = 53,
	[70][12] = 54,
	[70][13] = 89,
	[71][9] = 93,
	[71][11] = 94,
	[72][9] = 51,
	[72][10] = 95,
	[72][11] = 53,
	[72][12] = 54,
	[75][8] = 96,
	[75][9] = 51,
	[75][10] = 52,
	[75][11] = 53,
	[75][12] = 54,
	[75][13] = 55,
	[76][9] = 97,
	[80][17] = 103,
	[81][18] = 105,
	[82][19] = 107,
	[83][20] = 109,
	[84][21] = 111,
	[85][22] = 113,
	[87][16] = 121,
	[87][23] = 120,
	[91][8] = 122,
	[91][9] = 51,
	[91][10] = 52,
	[91][11] = 53,
	[91][12] = 54,
	[91][13] = 55,
	[92][9] = 123,
	[98][17] = 134,
	[98][24] = 132,
	[98][25] = 133,
	[98][26] = 135,
	[98][27] = 136,
	[104][17] = 148,
	[104][24] = 146,
	[104][25] = 147,
	[104][26] = 149,
	[104][27] = 150,
	[106][17] = 148,
	[106][24] = 151,
	[106][25] = 147,
	[106][26] = 149,
	[106][27] = 150,
	[108][17] = 148,
	[108][24] = 152,
	[108][25] = 147,
	[108][26] = 149,
	[108][27] = 150,
	[110][17] = 148,
	[110][24] = 153,
	[110][25] = 147,
	[110][26] = 149,
	[110][27] = 150,
	[114][18] = 154,
	[115][19] = 155,
	[116][20] = 156,
	[117][21] = 157,
	[118][15] = 158,
	[118][16] = 87,
	[119][22] = 159,
	[121][16] = 121,
	[121][23] = 160,
	[125][17] = 134,
	[125][24] = 162,
	[125][25] = 133,
	[125][26] = 135,
	[125][27] = 136,
	[126][17] = 164,
	[126][28] = 163,
	[127][17] = 164,
	[127][28] = 165,
	[138][17] = 148,
	[138][24] = 173,
	[138][25] = 147,
	[138][26] = 149,
	[138][27] = 150,
	[138][29] = 172,
	[139][17] = 134,
	[139][24] = 174,
	[139][25] = 133,
	[139][26] = 135,
	[139][27] = 136,
	[140][17] = 176,
	[140][28] = 175,
	[141][17] = 176,
	[141][28] = 177,
	[146][16] = 121,
	[146][23] = 178,
	[151][16] = 121,
	[151][23] = 183,
	[152][16] = 121,
	[152][23] = 184,
	[153][16] = 121,
	[153][23] = 185,
	[167][17] = 134,
	[167][26] = 188,
	[167][27] = 136,
	[167][30] = 187,
	[168][17] = 134,
	[168][26] = 188,
	[168][27] = 136,
	[168][30] = 189,
	[169][17] = 134,
	[169][27] = 191,
	[169][31] = 190,
	[170][17] = 134,
	[170][27] = 191,
	[170][31] = 192,
	[171][17] = 148,
	[171][24] = 173,
	[171][25] = 147,
	[171][26] = 149,
	[171][27] = 150,
	[171][29] = 193,
	[179][17] = 148,
	[179][26] = 196,
	[179][27] = 150,
	[179][30] = 195,
	[180][17] = 148,
	[180][26] = 196,
	[180][27] = 150,
	[180][30] = 197,
	[181][17] = 148,
	[181][27] = 199,
	[181][31] = 198,
	[182][17] = 148,
	[182][27] = 199,
	[182][31] = 200,
};


const unsigned zebu_lexer_starts[201] = {
	[1] = 1,
	[2] = 2,
	[3] = 1,
	[4] = 2,
	[5] = 3,
	[6] = 4,
	[7] = 5,
	[8] = 2,
	[9] = 6,
	[10] = 4,
	[11] = 7,
	[12] = 8,
	[13] = 9,
	[14] = 1,
	[15] = 9,
	[16] = 3,
	[17] = 10,
	[18] = 11,
	[19] = 9,
	[20] = 12,
	[21] = 10,
	[22] = 13,
	[23] = 3,
	[24] = 14,
	[25] = 15,
	[26] = 13,
	[27] = 16,
	[28] = 13,
	[29] = 17,
	[30] = 15,
	[31] = 18,
	[32] = 1,
	[33] = 6,
	[34] = 6,
	[35] = 6,
	[36] = 5,
	[37] = 7,
	[38] = 8,
	[39] = 10,
	[40] = 15,
	[41] = 2,
	[42] = 1,
	[43] = 12,
	[44] = 12,
	[45] = 12,
	[46] = 11,
	[47] = 19,
	[48] = 3,
	[49] = 14,
	[50] = 10,
	[51] = 19,
	[52] = 11,
	[53] = 19,
	[54] = 20,
	[55] = 10,
	[56] = 13,
	[57] = 2,
	[58] = 3,
	[59] = 3,
	[60] = 3,
	[61] = 21,
	[62] = 4,
	[63] = 7,
	[64] = 9,
	[65] = 9,
	[66] = 10,
	[67] = 10,
	[68] = 19,
	[69] = 13,
	[70] = 3,
	[71] = 3,
	[72] = 3,
	[73] = 15,
	[74] = 17,
	[75] = 3,
	[76] = 14,
	[77] = 17,
	[78] = 17,
	[79] = 16,
	[80] = 22,
	[81] = 4,
	[82] = 4,
	[83] = 4,
	[84] = 4,
	[85] = 23,
	[86] = 8,
	[87] = 24,
	[88] = 19,
	[89] = 10,
	[90] = 20,
	[91] = 3,
	[92] = 14,
	[93] = 20,
	[94] = 20,
	[95] = 11,
	[96] = 10,
	[97] = 17,
	[98] = 25,
	[99] = 26,
	[100] = 26,
	[101] = 26,
	[102] = 26,
	[103] = 26,
	[104] = 25,
	[105] = 8,
	[106] = 25,
	[107] = 8,
	[108] = 25,
	[109] = 8,
	[110] = 25,
	[111] = 8,
	[112] = 8,
	[113] = 8,
	[114] = 4,
	[115] = 4,
	[116] = 4,
	[117] = 4,
	[118] = 21,
	[119] = 23,
	[120] = 8,
	[121] = 24,
	[122] = 10,
	[123] = 20,
	[124] = 17,
	[125] = 25,
	[126] = 22,
	[127] = 22,
	[128] = 27,
	[129] = 27,
	[130] = 27,
	[131] = 27,
	[132] = 10,
	[133] = 28,
	[134] = 27,
	[135] = 27,
	[136] = 27,
	[137] = 4,
	[138] = 25,
	[139] = 25,
	[140] = 22,
	[141] = 22,
	[142] = 29,
	[143] = 29,
	[144] = 29,
	[145] = 29,
	[146] = 24,
	[147] = 30,
	[148] = 29,
	[149] = 29,
	[150] = 29,
	[151] = 24,
	[152] = 24,
	[153] = 24,
	[154] = 8,
	[155] = 8,
	[156] = 8,
	[157] = 8,
	[158] = 8,
	[159] = 8,
	[160] = 8,
	[161] = 20,
	[162] = 10,
	[163] = 27,
	[164] = 27,
	[165] = 27,
	[166] = 26,
	[167] = 25,
	[168] = 25,
	[169] = 25,
	[170] = 25,
	[171] = 25,
	[172] = 24,
	[173] = 24,
	[174] = 10,
	[175] = 29,
	[176] = 29,
	[177] = 29,
	[178] = 8,
	[179] = 25,
	[180] = 25,
	[181] = 25,
	[182] = 25,
	[183] = 8,
	[184] = 8,
	[185] = 8,
	[186] = 27,
	[187] = 28,
	[188] = 27,
	[189] = 28,
	[190] = 27,
	[191] = 27,
	[192] = 27,
	[193] = 24,
	[194] = 29,
	[195] = 30,
	[196] = 29,
	[197] = 30,
	[198] = 29,
	[199] = 29,
	[200] = 29,
};


const unsigned zebu_lexer[97][256] = {
	[1][9] = 31,
	[1][10] = 31,
	[1][32] = 31,
	[1][34] = 32,
	[1][39] = 33,
	[1][40] = 34,
	[1][47] = 35,
	[1][91] = 36,
	[2][9] = 31,
	[2][10] = 31,
	[2][32] = 31,
	[2][34] = 32,
	[2][39] = 33,
	[2][40] = 34,
	[2][42] = 37,
	[2][43] = 38,
	[2][47] = 35,
	[2][58] = 39,
	[2][63] = 40,
	[2][91] = 36,
	[2][124] = 41,
	[3][9] = 31,
	[3][10] = 31,
	[3][32] = 31,
	[3][33] = 42,
	[3][39] = 33,
	[3][40] = 34,
	[3][47] = 35,
	[4][9] = 31,
	[4][10] = 31,
	[4][32] = 31,
	[4][47] = 35,
	[4][58] = 39,
	[5][9] = 31,
	[5][10] = 31,
	[5][32] = 31,
	[5][47] = 35,
	[5][58] = 39,
	[5][124] = 41,
	[6][9] = 31,
	[6][10] = 31,
	[6][32] = 31,
	[6][34] = 32,
	[6][39] = 33,
	[6][40] = 34,
	[6][47] = 35,
	[6][58] = 39,
	[6][91] = 36,
	[6][124] = 41,
	[7][9] = 31,
	[7][10] = 31,
	[7][32] = 31,
	[7][47] = 35,
	[8][9] = 31,
	[8][10] = 31,
	[8][32] = 31,
	[8][34] = 32,
	[8][39] = 33,
	[8][40] = 34,
	[8][47] = 35,
	[8][91] = 36,
	[9][9] = 31,
	[9][10] = 31,
	[9][32] = 31,
	[9][34] = 32,
	[9][39] = 33,
	[9][40] = 34,
	[9][41] = 44,
	[9][42] = 37,
	[9][43] = 38,
	[9][47] = 35,
	[9][63] = 40,
	[9][91] = 36,
	[9][124] = 41,
	[10][9] = 31,
	[10][10] = 31,
	[10][32] = 31,
	[10][41] = 44,
	[10][47] = 35,
	[11][9] = 31,
	[11][10] = 31,
	[11][32] = 31,
	[11][41] = 44,
	[11][47] = 35,
	[11][124] = 41,
	[12][9] = 31,
	[12][10] = 31,
	[12][32] = 31,
	[12][34] = 32,
	[12][39] = 33,
	[12][40] = 34,
	[12][41] = 44,
	[12][47] = 35,
	[12][91] = 36,
	[12][124] = 41,
	[13][9] = 31,
	[13][10] = 31,
	[13][32] = 31,
	[13][38] = 45,
	[13][45] = 46,
	[13][47] = 35,
	[13][93] = 47,
	[13][124] = 41,
	[14][9] = 31,
	[14][10] = 31,
	[14][32] = 31,
	[14][39] = 33,
	[14][40] = 34,
	[14][47] = 35,
	[15][9] = 31,
	[15][10] = 31,
	[15][32] = 31,
	[15][47] = 35,
	[15][93] = 47,
	[16][9] = 31,
	[16][10] = 31,
	[16][32] = 31,
	[16][47] = 35,
	[16][93] = 47,
	[16][124] = 41,
	[17][9] = 31,
	[17][10] = 31,
	[17][32] = 31,
	[17][38] = 45,
	[17][47] = 35,
	[17][93] = 47,
	[17][124] = 41,
	[18][9] = 31,
	[18][10] = 31,
	[18][32] = 31,
	[18][47] = 35,
	[18][123] = 48,
	[19][9] = 31,
	[19][10] = 31,
	[19][32] = 31,
	[19][38] = 45,
	[19][41] = 44,
	[19][45] = 46,
	[19][47] = 35,
	[19][124] = 41,
	[20][9] = 31,
	[20][10] = 31,
	[20][32] = 31,
	[20][38] = 45,
	[20][41] = 44,
	[20][47] = 35,
	[20][124] = 41,
	[21][9] = 31,
	[21][10] = 31,
	[21][32] = 31,
	[21][47] = 35,
	[21][101] = 49,
	[21][109] = 50,
	[21][115] = 51,
	[21][119] = 52,
	[21][125] = 53,
	[22][9] = 31,
	[22][10] = 31,
	[22][32] = 31,
	[22][40] = 34,
	[22][47] = 35,
	[22][48] = 54,
	[22][49] = 55,
	[22][50] = 55,
	[22][51] = 55,
	[22][52] = 55,
	[22][53] = 55,
	[22][54] = 55,
	[22][55] = 55,
	[22][56] = 55,
	[22][57] = 55,
	[23][9] = 31,
	[23][10] = 31,
	[23][32] = 31,
	[23][47] = 35,
	[23][59] = 56,
	[24][9] = 31,
	[24][10] = 31,
	[24][32] = 31,
	[24][44] = 57,
	[24][47] = 35,
	[24][101] = 49,
	[24][109] = 50,
	[24][115] = 51,
	[24][119] = 52,
	[24][125] = 53,
	[25][9] = 31,
	[25][10] = 31,
	[25][32] = 31,
	[25][40] = 34,
	[25][43] = 38,
	[25][45] = 46,
	[25][47] = 35,
	[25][48] = 54,
	[25][49] = 55,
	[25][50] = 55,
	[25][51] = 55,
	[25][52] = 55,
	[25][53] = 55,
	[25][54] = 55,
	[25][55] = 55,
	[25][56] = 55,
	[25][57] = 55,
	[26][9] = 31,
	[26][10] = 31,
	[26][32] = 31,
	[26][37] = 58,
	[26][47] = 35,
	[26][58] = 39,
	[27][9] = 31,
	[27][10] = 31,
	[27][32] = 31,
	[27][41] = 44,
	[27][42] = 37,
	[27][43] = 38,
	[27][45] = 46,
	[27][47] = 59,
	[28][9] = 31,
	[28][10] = 31,
	[28][32] = 31,
	[28][41] = 44,
	[28][43] = 38,
	[28][45] = 46,
	[28][47] = 35,
	[29][9] = 31,
	[29][10] = 31,
	[29][32] = 31,
	[29][42] = 37,
	[29][43] = 38,
	[29][44] = 57,
	[29][45] = 46,
	[29][47] = 59,
	[29][101] = 49,
	[29][109] = 50,
	[29][115] = 51,
	[29][119] = 52,
	[29][125] = 53,
	[30][9] = 31,
	[30][10] = 31,
	[30][32] = 31,
	[30][43] = 38,
	[30][44] = 57,
	[30][45] = 46,
	[30][47] = 35,
	[30][101] = 49,
	[30][109] = 50,
	[30][115] = 51,
	[30][119] = 52,
	[30][125] = 53,
	[31][9] = 31,
	[31][10] = 31,
	[31][32] = 31,
	[31][47] = 35,
	[32][0] = 32,
	[32][1] = 32,
	[32][2] = 32,
	[32][3] = 32,
	[32][4] = 32,
	[32][5] = 32,
	[32][6] = 32,
	[32][7] = 32,
	[32][8] = 32,
	[32][9] = 32,
	[32][10] = 32,
	[32][11] = 32,
	[32][12] = 32,
	[32][13] = 32,
	[32][14] = 32,
	[32][15] = 32,
	[32][16] = 32,
	[32][17] = 32,
	[32][18] = 32,
	[32][19] = 32,
	[32][20] = 32,
	[32][21] = 32,
	[32][22] = 32,
	[32][23] = 32,
	[32][24] = 32,
	[32][25] = 32,
	[32][26] = 32,
	[32][27] = 32,
	[32][28] = 32,
	[32][29] = 32,
	[32][30] = 32,
	[32][31] = 32,
	[32][32] = 32,
	[32][33] = 32,
	[32][34] = 60,
	[32][35] = 32,
	[32][36] = 32,
	[32][37] = 32,
	[32][38] = 32,
	[32][39] = 32,
	[32][40] = 32,
	[32][41] = 32,
	[32][42] = 32,
	[32][43] = 32,
	[32][44] = 32,
	[32][45] = 32,
	[32][46] = 32,
	[32][47] = 32,
	[32][48] = 32,
	[32][49] = 32,
	[32][50] = 32,
	[32][51] = 32,
	[32][52] = 32,
	[32][53] = 32,
	[32][54] = 32,
	[32][55] = 32,
	[32][56] = 32,
	[32][57] = 32,
	[32][58] = 32,
	[32][59] = 32,
	[32][60] = 32,
	[32][61] = 32,
	[32][62] = 32,
	[32][63] = 32,
	[32][64] = 32,
	[32][65] = 32,
	[32][66] = 32,
	[32][67] = 32,
	[32][68] = 32,
	[32][69] = 32,
	[32][70] = 32,
	[32][71] = 32,
	[32][72] = 32,
	[32][73] = 32,
	[32][74] = 32,
	[32][75] = 32,
	[32][76] = 32,
	[32][77] = 32,
	[32][78] = 32,
	[32][79] = 32,
	[32][80] = 32,
	[32][81] = 32,
	[32][82] = 32,
	[32][83] = 32,
	[32][84] = 32,
	[32][85] = 32,
	[32][86] = 32,
	[32][87] = 32,
	[32][88] = 32,
	[32][89] = 32,
	[32][90] = 32,
	[32][91] = 32,
	[32][92] = 61,
	[32][93] = 32,
	[32][94] = 32,
	[32][95] = 32,
	[32][96] = 32,
	[32][97] = 32,
	[32][98] = 32,
	[32][99] = 32,
	[32][100] = 32,
	[32][101] = 32,
	[32][102] = 32,
	[32][103] = 32,
	[32][104] = 32,
	[32][105] = 32,
	[32][106] = 32,
	[32][107] = 32,
	[32][108] = 32,
	[32][109] = 32,
	[32][110] = 32,
	[32][111] = 32,
	[32][112] = 32,
	[32][113] = 32,
	[32][114] = 32,
	[32][115] = 32,
	[32][116] = 32,
	[32][117] = 32,
	[32][118] = 32,
	[32][119] = 32,
	[32][120] = 32,
	[32][121] = 32,
	[32][122] = 32,
	[32][123] = 32,
	[32][124] = 32,
	[32][125] = 32,
	[32][126] = 32,
	[32][127] = 32,
	[32][128] = 32,
	[32][129] = 32,
	[32][130] = 32,
	[32][131] = 32,
	[32][132] = 32,
	[32][133] = 32,
	[32][134] = 32,
	[32][135] = 32,
	[32][136] = 32,
	[32][137] = 32,
	[32][138] = 32,
	[32][139] = 32,
	[32][140] = 32,
	[32][141] = 32,
	[32][142] = 32,
	[32][143] = 32,
	[32][144] = 32,
	[32][145] = 32,
	[32][146] = 32,
	[32][147] = 32,
	[32][148] = 32,
	[32][149] = 32,
	[32][150] = 32,
	[32][151] = 32,
	[32][152] = 32,
	[32][153] = 32,
	[32][154] = 32,
	[32][155] = 32,
	[32][156] = 32,
	[32][157] = 32,
	[32][158] = 32,
	[32][159] = 32,
	[32][160] = 32,
	[32][161] = 32,
	[32][162] = 32,
	[32][163] = 32,
	[32][164] = 32,
	[32][165] = 32,
	[32][166] = 32,
	[32][167] = 32,
	[32][168] = 32,
	[32][169] = 32,
	[32][170] = 32,
	[32][171] = 32,
	[32][172] = 32,
	[32][173] = 32,
	[32][174] = 32,
	[32][175] = 32,
	[32][176] = 32,
	[32][177] = 32,
	[32][178] = 32,
	[32][179] = 32,
	[32][180] = 32,
	[32][181] = 32,
	[32][182] = 32,
	[32][183] = 32,
	[32][184] = 32,
	[32][185] = 32,
	[32][186] = 32,
	[32][187] = 32,
	[32][188] = 32,
	[32][189] = 32,
	[32][190] = 32,
	[32][191] = 32,
	[32][192] = 32,
	[32][193] = 32,
	[32][194] = 32,
	[32][195] = 32,
	[32][196] = 32,
	[32][197] = 32,
	[32][198] = 32,
	[32][199] = 32,
	[32][200] = 32,
	[32][201] = 32,
	[32][202] = 32,
	[32][203] = 32,
	[32][204] = 32,
	[32][205] = 32,
	[32][206] = 32,
	[32][207] = 32,
	[32][208] = 32,
	[32][209] = 32,
	[32][210] = 32,
	[32][211] = 32,
	[32][212] = 32,
	[32][213] = 32,
	[32][214] = 32,
	[32][215] = 32,
	[32][216] = 32,
	[32][217] = 32,
	[32][218] = 32,
	[32][219] = 32,
	[32][220] = 32,
	[32][221] = 32,
	[32][222] = 32,
	[32][223] = 32,
	[32][224] = 32,
	[32][225] = 32,
	[32][226] = 32,
	[32][227] = 32,
	[32][228] = 32,
	[32][229] = 32,
	[32][230] = 32,
	[32][231] = 32,
	[32][232] = 32,
	[32][233] = 32,
	[32][234] = 32,
	[32][235] = 32,
	[32][236] = 32,
	[32][237] = 32,
	[32][238] = 32,
	[32][239] = 32,
	[32][240] = 32,
	[32][241] = 32,
	[32][242] = 32,
	[32][243] = 32,
	[32][244] = 32,
	[32][245] = 32,
	[32][246] = 32,
	[32][247] = 32,
	[32][248] = 32,
	[32][249] = 32,
	[32][250] = 32,
	[32][251] = 32,
	[32][252] = 32,
	[32][253] = 32,
	[32][254] = 32,
	[32][255] = 32,
	[33][0] = 62,
	[33][1] = 62,
	[33][2] = 62,
	[33][3] = 62,
	[33][4] = 62,
	[33][5] = 62,
	[33][6] = 62,
	[33][7] = 62,
	[33][8] = 62,
	[33][9] = 62,
	[33][10] = 62,
	[33][11] = 62,
	[33][12] = 62,
	[33][13] = 62,
	[33][14] = 62,
	[33][15] = 62,
	[33][16] = 62,
	[33][17] = 62,
	[33][18] = 62,
	[33][19] = 62,
	[33][20] = 62,
	[33][21] = 62,
	[33][22] = 62,
	[33][23] = 62,
	[33][24] = 62,
	[33][25] = 62,
	[33][26] = 62,
	[33][27] = 62,
	[33][28] = 62,
	[33][29] = 62,
	[33][30] = 62,
	[33][31] = 62,
	[33][32] = 62,
	[33][33] = 62,
	[33][34] = 62,
	[33][35] = 62,
	[33][36] = 62,
	[33][37] = 62,
	[33][38] = 62,
	[33][40] = 62,
	[33][41] = 62,
	[33][42] = 62,
	[33][43] = 62,
	[33][44] = 62,
	[33][45] = 62,
	[33][46] = 62,
	[33][47] = 62,
	[33][48] = 62,
	[33][49] = 62,
	[33][50] = 62,
	[33][51] = 62,
	[33][52] = 62,
	[33][53] = 62,
	[33][54] = 62,
	[33][55] = 62,
	[33][56] = 62,
	[33][57] = 62,
	[33][58] = 62,
	[33][59] = 62,
	[33][60] = 62,
	[33][61] = 62,
	[33][62] = 62,
	[33][63] = 62,
	[33][64] = 62,
	[33][65] = 62,
	[33][66] = 62,
	[33][67] = 62,
	[33][68] = 62,
	[33][69] = 62,
	[33][70] = 62,
	[33][71] = 62,
	[33][72] = 62,
	[33][73] = 62,
	[33][74] = 62,
	[33][75] = 62,
	[33][76] = 62,
	[33][77] = 62,
	[33][78] = 62,
	[33][79] = 62,
	[33][80] = 62,
	[33][81] = 62,
	[33][82] = 62,
	[33][83] = 62,
	[33][84] = 62,
	[33][85] = 62,
	[33][86] = 62,
	[33][87] = 62,
	[33][88] = 62,
	[33][89] = 62,
	[33][90] = 62,
	[33][91] = 62,
	[33][92] = 63,
	[33][93] = 62,
	[33][94] = 62,
	[33][95] = 62,
	[33][96] = 62,
	[33][97] = 62,
	[33][98] = 62,
	[33][99] = 62,
	[33][100] = 62,
	[33][101] = 62,
	[33][102] = 62,
	[33][103] = 62,
	[33][104] = 62,
	[33][105] = 62,
	[33][106] = 62,
	[33][107] = 62,
	[33][108] = 62,
	[33][109] = 62,
	[33][110] = 62,
	[33][111] = 62,
	[33][112] = 62,
	[33][113] = 62,
	[33][114] = 62,
	[33][115] = 62,
	[33][116] = 62,
	[33][117] = 62,
	[33][118] = 62,
	[33][119] = 62,
	[33][120] = 62,
	[33][121] = 62,
	[33][122] = 62,
	[33][123] = 62,
	[33][124] = 62,
	[33][125] = 62,
	[33][126] = 62,
	[33][127] = 62,
	[33][128] = 62,
	[33][129] = 62,
	[33][130] = 62,
	[33][131] = 62,
	[33][132] = 62,
	[33][133] = 62,
	[33][134] = 62,
	[33][135] = 62,
	[33][136] = 62,
	[33][137] = 62,
	[33][138] = 62,
	[33][139] = 62,
	[33][140] = 62,
	[33][141] = 62,
	[33][142] = 62,
	[33][143] = 62,
	[33][144] = 62,
	[33][145] = 62,
	[33][146] = 62,
	[33][147] = 62,
	[33][148] = 62,
	[33][149] = 62,
	[33][150] = 62,
	[33][151] = 62,
	[33][152] = 62,
	[33][153] = 62,
	[33][154] = 62,
	[33][155] = 62,
	[33][156] = 62,
	[33][157] = 62,
	[33][158] = 62,
	[33][159] = 62,
	[33][160] = 62,
	[33][161] = 62,
	[33][162] = 62,
	[33][163] = 62,
	[33][164] = 62,
	[33][165] = 62,
	[33][166] = 62,
	[33][167] = 62,
	[33][168] = 62,
	[33][169] = 62,
	[33][170] = 62,
	[33][171] = 62,
	[33][172] = 62,
	[33][173] = 62,
	[33][174] = 62,
	[33][175] = 62,
	[33][176] = 62,
	[33][177] = 62,
	[33][178] = 62,
	[33][179] = 62,
	[33][180] = 62,
	[33][181] = 62,
	[33][182] = 62,
	[33][183] = 62,
	[33][184] = 62,
	[33][185] = 62,
	[33][186] = 62,
	[33][187] = 62,
	[33][188] = 62,
	[33][189] = 62,
	[33][190] = 62,
	[33][191] = 62,
	[33][192] = 62,
	[33][193] = 62,
	[33][194] = 62,
	[33][195] = 62,
	[33][196] = 62,
	[33][197] = 62,
	[33][198] = 62,
	[33][199] = 62,
	[33][200] = 62,
	[33][201] = 62,
	[33][202] = 62,
	[33][203] = 62,
	[33][204] = 62,
	[33][205] = 62,
	[33][206] = 62,
	[33][207] = 62,
	[33][208] = 62,
	[33][209] = 62,
	[33][210] = 62,
	[33][211] = 62,
	[33][212] = 62,
	[33][213] = 62,
	[33][214] = 62,
	[33][215] = 62,
	[33][216] = 62,
	[33][217] = 62,
	[33][218] = 62,
	[33][219] = 62,
	[33][220] = 62,
	[33][221] = 62,
	[33][222] = 62,
	[33][223] = 62,
	[33][224] = 62,
	[33][225] = 62,
	[33][226] = 62,
	[33][227] = 62,
	[33][228] = 62,
	[33][229] = 62,
	[33][230] = 62,
	[33][231] = 62,
	[33][232] = 62,
	[33][233] = 62,
	[33][234] = 62,
	[33][235] = 62,
	[33][236] = 62,
	[33][237] = 62,
	[33][238] = 62,
	[33][239] = 62,
	[33][240] = 62,
	[33][241] = 62,
	[33][242] = 62,
	[33][243] = 62,
	[33][244] = 62,
	[33][245] = 62,
	[33][246] = 62,
	[33][247] = 62,
	[33][248] = 62,
	[33][249] = 62,
	[33][250] = 62,
	[33][251] = 62,
	[33][252] = 62,
	[33][253] = 62,
	[33][254] = 62,
	[33][255] = 62,
	[35][47] = 64,
	[49][120] = 65,
	[50][105] = 66,
	[51][105] = 67,
	[52][105] = 68,
	[54][46] = 69,
	[54][48] = 55,
	[54][49] = 55,
	[54][50] = 55,
	[54][51] = 55,
	[54][52] = 55,
	[54][53] = 55,
	[54][54] = 55,
	[54][55] = 55,
	[54][56] = 55,
	[54][57] = 55,
	[54][98] = 70,
	[54][111] = 71,
	[54][120] = 72,
	[55][46] = 69,
	[55][48] = 55,
	[55][49] = 55,
	[55][50] = 55,
	[55][51] = 55,
	[55][52] = 55,
	[55][53] = 55,
	[55][54] = 55,
	[55][55] = 55,
	[55][56] = 55,
	[55][57] = 55,
	[59][47] = 64,
	[61][34] = 32,
	[61][110] = 32,
	[61][116] = 32,
	[62][39] = 73,
	[63][34] = 62,
	[63][110] = 62,
	[63][116] = 62,
	[64][0] = 64,
	[64][1] = 64,
	[64][2] = 64,
	[64][3] = 64,
	[64][4] = 64,
	[64][5] = 64,
	[64][6] = 64,
	[64][7] = 64,
	[64][8] = 64,
	[64][9] = 64,
	[64][10] = 31,
	[64][11] = 64,
	[64][12] = 64,
	[64][13] = 64,
	[64][14] = 64,
	[64][15] = 64,
	[64][16] = 64,
	[64][17] = 64,
	[64][18] = 64,
	[64][19] = 64,
	[64][20] = 64,
	[64][21] = 64,
	[64][22] = 64,
	[64][23] = 64,
	[64][24] = 64,
	[64][25] = 64,
	[64][26] = 64,
	[64][27] = 64,
	[64][28] = 64,
	[64][29] = 64,
	[64][30] = 64,
	[64][31] = 64,
	[64][32] = 64,
	[64][33] = 64,
	[64][34] = 64,
	[64][35] = 64,
	[64][36] = 64,
	[64][37] = 64,
	[64][38] = 64,
	[64][39] = 64,
	[64][40] = 64,
	[64][41] = 64,
	[64][42] = 64,
	[64][43] = 64,
	[64][44] = 64,
	[64][45] = 64,
	[64][46] = 64,
	[64][47] = 64,
	[64][48] = 64,
	[64][49] = 64,
	[64][50] = 64,
	[64][51] = 64,
	[64][52] = 64,
	[64][53] = 64,
	[64][54] = 64,
	[64][55] = 64,
	[64][56] = 64,
	[64][57] = 64,
	[64][58] = 64,
	[64][59] = 64,
	[64][60] = 64,
	[64][61] = 64,
	[64][62] = 64,
	[64][63] = 64,
	[64][64] = 64,
	[64][65] = 64,
	[64][66] = 64,
	[64][67] = 64,
	[64][68] = 64,
	[64][69] = 64,
	[64][70] = 64,
	[64][71] = 64,
	[64][72] = 64,
	[64][73] = 64,
	[64][74] = 64,
	[64][75] = 64,
	[64][76] = 64,
	[64][77] = 64,
	[64][78] = 64,
	[64][79] = 64,
	[64][80] = 64,
	[64][81] = 64,
	[64][82] = 64,
	[64][83] = 64,
	[64][84] = 64,
	[64][85] = 64,
	[64][86] = 64,
	[64][87] = 64,
	[64][88] = 64,
	[64][89] = 64,
	[64][90] = 64,
	[64][91] = 64,
	[64][92] = 64,
	[64][93] = 64,
	[64][94] = 64,
	[64][95] = 64,
	[64][96] = 64,
	[64][97] = 64,
	[64][98] = 64,
	[64][99] = 64,
	[64][100] = 64,
	[64][101] = 64,
	[64][102] = 64,
	[64][103] = 64,
	[64][104] = 64,
	[64][105] = 64,
	[64][106] = 64,
	[64][107] = 64,
	[64][108] = 64,
	[64][109] = 64,
	[64][110] = 64,
	[64][111] = 64,
	[64][112] = 64,
	[64][113] = 64,
	[64][114] = 64,
	[64][115] = 64,
	[64][116] = 64,
	[64][117] = 64,
	[64][118] = 64,
	[64][119] = 64,
	[64][120] = 64,
	[64][121] = 64,
	[64][122] = 64,
	[64][123] = 64,
	[64][124] = 64,
	[64][125] = 64,
	[64][126] = 64,
	[64][127] = 64,
	[64][128] = 64,
	[64][129] = 64,
	[64][130] = 64,
	[64][131] = 64,
	[64][132] = 64,
	[64][133] = 64,
	[64][134] = 64,
	[64][135] = 64,
	[64][136] = 64,
	[64][137] = 64,
	[64][138] = 64,
	[64][139] = 64,
	[64][140] = 64,
	[64][141] = 64,
	[64][142] = 64,
	[64][143] = 64,
	[64][144] = 64,
	[64][145] = 64,
	[64][146] = 64,
	[64][147] = 64,
	[64][148] = 64,
	[64][149] = 64,
	[64][150] = 64,
	[64][151] = 64,
	[64][152] = 64,
	[64][153] = 64,
	[64][154] = 64,
	[64][155] = 64,
	[64][156] = 64,
	[64][157] = 64,
	[64][158] = 64,
	[64][159] = 64,
	[64][160] = 64,
	[64][161] = 64,
	[64][162] = 64,
	[64][163] = 64,
	[64][164] = 64,
	[64][165] = 64,
	[64][166] = 64,
	[64][167] = 64,
	[64][168] = 64,
	[64][169] = 64,
	[64][170] = 64,
	[64][171] = 64,
	[64][172] = 64,
	[64][173] = 64,
	[64][174] = 64,
	[64][175] = 64,
	[64][176] = 64,
	[64][177] = 64,
	[64][178] = 64,
	[64][179] = 64,
	[64][180] = 64,
	[64][181] = 64,
	[64][182] = 64,
	[64][183] = 64,
	[64][184] = 64,
	[64][185] = 64,
	[64][186] = 64,
	[64][187] = 64,
	[64][188] = 64,
	[64][189] = 64,
	[64][190] = 64,
	[64][191] = 64,
	[64][192] = 64,
	[64][193] = 64,
	[64][194] = 64,
	[64][195] = 64,
	[64][196] = 64,
	[64][197] = 64,
	[64][198] = 64,
	[64][199] = 64,
	[64][200] = 64,
	[64][201] = 64,
	[64][202] = 64,
	[64][203] = 64,
	[64][204] = 64,
	[64][205] = 64,
	[64][206] = 64,
	[64][207] = 64,
	[64][208] = 64,
	[64][209] = 64,
	[64][210] = 64,
	[64][211] = 64,
	[64][212] = 64,
	[64][213] = 64,
	[64][214] = 64,
	[64][215] = 64,
	[64][216] = 64,
	[64][217] = 64,
	[64][218] = 64,
	[64][219] = 64,
	[64][220] = 64,
	[64][221] = 64,
	[64][222] = 64,
	[64][223] = 64,
	[64][224] = 64,
	[64][225] = 64,
	[64][226] = 64,
	[64][227] = 64,
	[64][228] = 64,
	[64][229] = 64,
	[64][230] = 64,
	[64][231] = 64,
	[64][232] = 64,
	[64][233] = 64,
	[64][234] = 64,
	[64][235] = 64,
	[64][236] = 64,
	[64][237] = 64,
	[64][238] = 64,
	[64][239] = 64,
	[64][240] = 64,
	[64][241] = 64,
	[64][242] = 64,
	[64][243] = 64,
	[64][244] = 64,
	[64][245] = 64,
	[64][246] = 64,
	[64][247] = 64,
	[64][248] = 64,
	[64][249] = 64,
	[64][250] = 64,
	[64][251] = 64,
	[64][252] = 64,
	[64][253] = 64,
	[64][254] = 64,
	[64][255] = 64,
	[65][97] = 74,
	[65][116] = 75,
	[66][115] = 76,
	[67][109] = 77,
	[68][116] = 78,
	[69][48] = 69,
	[69][49] = 69,
	[69][50] = 69,
	[69][51] = 69,
	[69][52] = 69,
	[69][53] = 69,
	[69][54] = 69,
	[69][55] = 69,
	[69][56] = 69,
	[69][57] = 69,
	[70][48] = 79,
	[70][49] = 79,
	[71][48] = 80,
	[71][49] = 80,
	[71][50] = 80,
	[71][51] = 80,
	[71][52] = 80,
	[71][53] = 80,
	[71][54] = 80,
	[71][55] = 80,
	[72][48] = 81,
	[72][49] = 81,
	[72][50] = 81,
	[72][51] = 81,
	[72][52] = 81,
	[72][53] = 81,
	[72][54] = 81,
	[72][55] = 81,
	[72][56] = 81,
	[72][57] = 81,
	[72][65] = 81,
	[72][66] = 81,
	[72][67] = 81,
	[72][68] = 81,
	[72][69] = 81,
	[72][70] = 81,
	[74][99] = 82,
	[75][114] = 83,
	[76][115] = 84,
	[77][105] = 85,
	[78][104] = 86,
	[79][46] = 87,
	[79][48] = 79,
	[79][49] = 79,
	[80][46] = 88,
	[80][48] = 80,
	[80][49] = 80,
	[80][50] = 80,
	[80][51] = 80,
	[80][52] = 80,
	[80][53] = 80,
	[80][54] = 80,
	[80][55] = 80,
	[81][46] = 89,
	[81][48] = 81,
	[81][49] = 81,
	[81][50] = 81,
	[81][51] = 81,
	[81][52] = 81,
	[81][53] = 81,
	[81][54] = 81,
	[81][55] = 81,
	[81][56] = 81,
	[81][57] = 81,
	[81][65] = 81,
	[81][66] = 81,
	[81][67] = 81,
	[81][68] = 81,
	[81][69] = 81,
	[81][70] = 81,
	[82][116] = 90,
	[83][97] = 91,
	[84][105] = 92,
	[85][108] = 93,
	[86][105] = 94,
	[87][48] = 87,
	[87][49] = 87,
	[88][48] = 88,
	[88][49] = 88,
	[88][50] = 88,
	[88][51] = 88,
	[88][52] = 88,
	[88][53] = 88,
	[88][54] = 88,
	[88][55] = 88,
	[89][48] = 89,
	[89][49] = 89,
	[89][50] = 89,
	[89][51] = 89,
	[89][52] = 89,
	[89][53] = 89,
	[89][54] = 89,
	[89][55] = 89,
	[89][56] = 89,
	[89][57] = 89,
	[89][65] = 89,
	[89][66] = 89,
	[89][67] = 89,
	[89][68] = 89,
	[89][69] = 89,
	[89][70] = 89,
	[92][110] = 95,
	[93][97] = 96,
	[94][110] = 97,
	[95][103] = 98,
	[96][114] = 99,
};


const unsigned zebu_lexer_accepts[100] = {
	[31] = 1,
	[34] = 3,
	[36] = 5,
	[37] = 8,
	[38] = 9,
	[39] = 10,
	[40] = 7,
	[41] = 6,
	[42] = 11,
	[43] = 12,
	[44] = 13,
	[45] = 15,
	[46] = 14,
	[47] = 16,
	[48] = 17,
	[53] = 23,
	[54] = 24,
	[55] = 24,
	[56] = 28,
	[57] = 29,
	[58] = 30,
	[59] = 31,
	[60] = 4,
	[69] = 24,
	[73] = 2,
	[79] = 25,
	[80] = 26,
	[81] = 27,
	[87] = 25,
	[88] = 26,
	[89] = 27,
	[90] = 21,
	[91] = 19,
	[97] = 18,
	[98] = 22,
	[99] = 20,
};


const unsigned zebu_lexer_EOFs[9] = {
	[7] = 43,
	[8] = 43,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
    bool is_last;
    struct link* prev;
};

static void print_links(struct link* link)
{
    if (!link) return;
    print_links(link->prev);
    fputs(link->is_last ? "    " : "│   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
    switch (in)
    {
        case ' ':
        case '~':
        case '!':
        case '@':
        case '#':
        case '$':
        case '%':
        case '^':
        case '&':
        case '*':
        case '-':
        case '+':
        case '=':
        case '|':
        case '<': case '>':
        case '(': case ')':
        case '{': case '}':
        case '[': case ']':
        case ':': case ';':
        case ',': case '.':
        case '_':
        case '/':
        case '`':
        case '0' ... '9':
        case 'a' ... 'z':
        case 'A' ... 'Z':
            *out++ = in;
            *out = 0;
            break;
        
        case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
        
        case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
        
        case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
        
        case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
        
        case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
        
        default:
            sprintf(out, "\\x%02X", in);
            break;
    }
}

enum prefix
{
p_root,
p_not_last_child,
p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
print_links(links);
switch (p)
{
case p_root: break;
case p_not_last_child: fputs("├── ", stdout); break;
case p_last_child: fputs("└── ", stdout); break;
}
printf("\e[32m%s\e[0m (\e[35m\"", name);
char escape[10];
for (unsigned i = 0, n = token->len; i < n; i++)
print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
printf("\"\e[0m)");
#if ZEBU_LINE_NUMBERS
printf(" on line %u", token->line);
#endif
printf("\n");
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
va_list ap;
print_links(links);
switch (p)
{
case p_root: break;
case p_not_last_child: fputs("├── ", stdout); break;
case p_last_child: fputs("└── ", stdout); break;
}
printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
va_start(ap, format);
vprintf(format, ap);
va_end(ap);
printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
print_links(links);
switch (p)
{
case p_root: break;
case p_not_last_child: fputs("├── ", stdout); break;
case p_last_child: fputs("└── ", stdout); break;
}
printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_charset(struct link* links, enum prefix p, const char* name, struct zebu_charset* ptree);

void print_zebu_charset_high(struct link* links, enum prefix p, const char* name, struct zebu_charset_high* ptree);

void print_zebu_charset_inter(struct link* links, enum prefix p, const char* name, struct zebu_charset_inter* ptree);

void print_zebu_charset_prefix(struct link* links, enum prefix p, const char* name, struct zebu_charset_prefix* ptree);

void print_zebu_charset_range(struct link* links, enum prefix p, const char* name, struct zebu_charset_range* ptree);

void print_zebu_charset_union(struct link* links, enum prefix p, const char* name, struct zebu_charset_union* ptree);

void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree);

void print_zebu_expression_additive(struct link* links, enum prefix p, const char* name, struct zebu_expression_additive* ptree);

void print_zebu_expression_highest(struct link* links, enum prefix p, const char* name, struct zebu_expression_highest* ptree);

void print_zebu_expression_multiplicative(struct link* links, enum prefix p, const char* name, struct zebu_expression_multiplicative* ptree);

void print_zebu_expression_prefix(struct link* links, enum prefix p, const char* name, struct zebu_expression_prefix* ptree);

void print_zebu_regex(struct link* links, enum prefix p, const char* name, struct zebu_regex* ptree);

void print_zebu_regex_concat(struct link* links, enum prefix p, const char* name, struct zebu_regex_concat* ptree);

void print_zebu_regex_high(struct link* links, enum prefix p, const char* name, struct zebu_regex_high* ptree);

void print_zebu_regex_suffix(struct link* links, enum prefix p, const char* name, struct zebu_regex_suffix* ptree);

void print_zebu_regex_union(struct link* links, enum prefix p, const char* name, struct zebu_regex_union* ptree);

void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree);

void print_zebu_token_rule(struct link* links, enum prefix p, const char* name, struct zebu_token_rule* ptree);

void print_zebu_within(struct link* links, enum prefix p, const char* name, struct zebu_within* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36m$start\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->root)
print_zebu_root(new ?: links, p_last_child, "root", ptree->root);
else
print_empty_leaf(new ?: links, p_last_child, "root", "root");
free(new);
}
void print_zebu_charset(struct link* links, enum prefix p, const char* name, struct zebu_charset* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mcharset\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_charset_union(new ?: links, p_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_last_child, "charset_union", "inner");
free(new);
}
void print_zebu_charset_high(struct link* links, enum prefix p, const char* name, struct zebu_charset_high* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mcharset_high\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->character)
print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
if (ptree->inner)
print_zebu_charset(new ?: links, p_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_last_child, "charset", "inner");
free(new);
}
void print_zebu_charset_inter(struct link* links, enum prefix p, const char* name, struct zebu_charset_inter* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mcharset_inter\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_charset_range(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "charset_range", "inner");
if (ptree->sub)
print_zebu_charset_inter(new ?: links, p_last_child, "sub", ptree->sub);
else
print_empty_leaf(new ?: links, p_last_child, "charset_inter", "sub");
free(new);
}
void print_zebu_charset_prefix(struct link* links, enum prefix p, const char* name, struct zebu_charset_prefix* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mcharset_prefix\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->emark)
print_token_leaf(new ?: links, p_not_last_child, "emark", ptree->emark);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "emark");
if (ptree->inner)
print_zebu_charset_high(new ?: links, p_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_last_child, "charset_high", "inner");
free(new);
}
void print_zebu_charset_range(struct link* links, enum prefix p, const char* name, struct zebu_charset_range* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mcharset_range\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->left)
print_zebu_charset_prefix(new ?: links, p_not_last_child, "left", ptree->left);
else
print_empty_leaf(new ?: links, p_not_last_child, "charset_prefix", "left");
if (ptree->right)
print_zebu_charset_prefix(new ?: links, p_last_child, "right", ptree->right);
else
print_empty_leaf(new ?: links, p_last_child, "charset_prefix", "right");
free(new);
}
void print_zebu_charset_union(struct link* links, enum prefix p, const char* name, struct zebu_charset_union* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mcharset_union\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_charset_inter(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "charset_inter", "inner");
if (ptree->sub)
print_zebu_charset_union(new ?: links, p_last_child, "sub", ptree->sub);
else
print_empty_leaf(new ?: links, p_last_child, "charset_union", "sub");
free(new);
}
void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mexpression\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_expression_additive(new ?: links, p_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_last_child, "expression_additive", "inner");
free(new);
}
void print_zebu_expression_additive(struct link* links, enum prefix p, const char* name, struct zebu_expression_additive* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mexpression_additive\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->add)
print_token_leaf(new ?: links, p_not_last_child, "add", ptree->add);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "add");
if (ptree->inner)
print_zebu_expression_multiplicative(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression_multiplicative", "inner");
if (ptree->left)
print_zebu_expression_additive(new ?: links, p_not_last_child, "left", ptree->left);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression_additive", "left");
if (ptree->right)
print_zebu_expression_multiplicative(new ?: links, p_not_last_child, "right", ptree->right);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression_multiplicative", "right");
if (ptree->sub)
print_token_leaf(new ?: links, p_last_child, "sub", ptree->sub);
else
print_empty_leaf(new ?: links, p_last_child, "token", "sub");
free(new);
}
void print_zebu_expression_highest(struct link* links, enum prefix p, const char* name, struct zebu_expression_highest* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mexpression_highest\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->binary)
print_token_leaf(new ?: links, p_not_last_child, "binary", ptree->binary);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "binary");
if (ptree->decimal)
print_token_leaf(new ?: links, p_not_last_child, "decimal", ptree->decimal);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "decimal");
if (ptree->hexadecimal)
print_token_leaf(new ?: links, p_not_last_child, "hexadecimal", ptree->hexadecimal);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "hexadecimal");
if (ptree->inner)
print_zebu_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "inner");
if (ptree->octal)
print_token_leaf(new ?: links, p_last_child, "octal", ptree->octal);
else
print_empty_leaf(new ?: links, p_last_child, "token", "octal");
free(new);
}
void print_zebu_expression_multiplicative(struct link* links, enum prefix p, const char* name, struct zebu_expression_multiplicative* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mexpression_multiplicative\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->div)
print_token_leaf(new ?: links, p_not_last_child, "div", ptree->div);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "div");
if (ptree->inner)
print_zebu_expression_prefix(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression_prefix", "inner");
if (ptree->left)
print_zebu_expression_multiplicative(new ?: links, p_not_last_child, "left", ptree->left);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression_multiplicative", "left");
if (ptree->mul)
print_token_leaf(new ?: links, p_not_last_child, "mul", ptree->mul);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "mul");
if (ptree->right)
print_zebu_expression_prefix(new ?: links, p_last_child, "right", ptree->right);
else
print_empty_leaf(new ?: links, p_last_child, "expression_prefix", "right");
free(new);
}
void print_zebu_expression_prefix(struct link* links, enum prefix p, const char* name, struct zebu_expression_prefix* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mexpression_prefix\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_expression_highest(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression_highest", "inner");
if (ptree->negate)
print_token_leaf(new ?: links, p_last_child, "negate", ptree->negate);
else
print_empty_leaf(new ?: links, p_last_child, "token", "negate");
free(new);
}
void print_zebu_regex(struct link* links, enum prefix p, const char* name, struct zebu_regex* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mregex\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_regex_union(new ?: links, p_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_last_child, "regex_union", "inner");
free(new);
}
void print_zebu_regex_concat(struct link* links, enum prefix p, const char* name, struct zebu_regex_concat* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mregex_concat\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_regex_suffix(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "regex_suffix", "inner");
if (ptree->sub)
print_zebu_regex_concat(new ?: links, p_last_child, "sub", ptree->sub);
else
print_empty_leaf(new ?: links, p_last_child, "regex_concat", "sub");
free(new);
}
void print_zebu_regex_high(struct link* links, enum prefix p, const char* name, struct zebu_regex_high* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mregex_high\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->character)
print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
if (ptree->charset)
print_zebu_charset(new ?: links, p_not_last_child, "charset", ptree->charset);
else
print_empty_leaf(new ?: links, p_not_last_child, "charset", "charset");
if (ptree->string)
print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
if (ptree->sub)
print_zebu_regex(new ?: links, p_last_child, "sub", ptree->sub);
else
print_empty_leaf(new ?: links, p_last_child, "regex", "sub");
free(new);
}
void print_zebu_regex_suffix(struct link* links, enum prefix p, const char* name, struct zebu_regex_suffix* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mregex_suffix\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->asterisk)
print_token_leaf(new ?: links, p_not_last_child, "asterisk", ptree->asterisk);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "asterisk");
if (ptree->inner)
print_zebu_regex_high(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "regex_high", "inner");
if (ptree->plus)
print_token_leaf(new ?: links, p_not_last_child, "plus", ptree->plus);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "plus");
if (ptree->qmark)
print_token_leaf(new ?: links, p_last_child, "qmark", ptree->qmark);
else
print_empty_leaf(new ?: links, p_last_child, "token", "qmark");
free(new);
}
void print_zebu_regex_union(struct link* links, enum prefix p, const char* name, struct zebu_regex_union* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mregex_union\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_regex_concat(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "regex_concat", "inner");
if (ptree->sub)
print_zebu_regex_union(new ?: links, p_last_child, "sub", ptree->sub);
else
print_empty_leaf(new ?: links, p_last_child, "regex_union", "sub");
free(new);
}
void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mroot\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->rules.n)
{
for (unsigned i = 0, n = ptree->rules.n; i < n; i++)
{
char label[5 + 30];
snprintf(label, sizeof(label), "rules[%u]", i);
print_zebu_token_rule(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->rules.data[i]);
}
}
else
{
print_empty_leaf(new ?: links, p_last_child, "token_rule[]", "rules");
}
free(new);
}
void print_zebu_token_rule(struct link* links, enum prefix p, const char* name, struct zebu_token_rule* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mtoken_rule\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->delete)
print_zebu_expression(new ?: links, p_not_last_child, "delete", ptree->delete);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "delete");
if (ptree->insert)
print_zebu_expression(new ?: links, p_not_last_child, "insert", ptree->insert);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "insert");
if (ptree->match)
print_zebu_expression(new ?: links, p_not_last_child, "match", ptree->match);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "match");
if (ptree->regex)
print_zebu_regex(new ?: links, p_not_last_child, "regex", ptree->regex);
else
print_empty_leaf(new ?: links, p_not_last_child, "regex", "regex");
if (ptree->update)
print_zebu_expression(new ?: links, p_not_last_child, "update", ptree->update);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "update");
if (ptree->withins.n)
{
for (unsigned i = 0, n = ptree->withins.n; i < n; i++)
{
char label[7 + 30];
snprintf(label, sizeof(label), "withins[%u]", i);
print_zebu_within(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->withins.data[i]);
}
}
else
{
print_empty_leaf(new ?: links, p_last_child, "within[]", "withins");
}
free(new);
}
void print_zebu_within(struct link* links, enum prefix p, const char* name, struct zebu_within* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mwithin\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->percent)
print_token_leaf(new ?: links, p_not_last_child, "percent", ptree->percent);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "percent");
if (ptree->points)
print_zebu_expression(new ?: links, p_not_last_child, "points", ptree->points);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "points");
if (ptree->tolerance)
print_zebu_expression_highest(new ?: links, p_last_child, "tolerance", ptree->tolerance);
else
print_empty_leaf(new ?: links, p_last_child, "expression_highest", "tolerance");
free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* token)
{
	if (token) token->refcount++;
	return token;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset* inc_zebu_charset(struct zebu_charset* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_high* inc_zebu_charset_high(struct zebu_charset_high* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_inter* inc_zebu_charset_inter(struct zebu_charset_inter* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_prefix* inc_zebu_charset_prefix(struct zebu_charset_prefix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_range* inc_zebu_charset_range(struct zebu_charset_range* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_union* inc_zebu_charset_union(struct zebu_charset_union* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression* inc_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression_additive* inc_zebu_expression_additive(struct zebu_expression_additive* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression_highest* inc_zebu_expression_highest(struct zebu_expression_highest* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression_multiplicative* inc_zebu_expression_multiplicative(struct zebu_expression_multiplicative* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression_prefix* inc_zebu_expression_prefix(struct zebu_expression_prefix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex* inc_zebu_regex(struct zebu_regex* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_concat* inc_zebu_regex_concat(struct zebu_regex_concat* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_high* inc_zebu_regex_high(struct zebu_regex_high* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_suffix* inc_zebu_regex_suffix(struct zebu_regex_suffix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_union* inc_zebu_regex_union(struct zebu_regex_union* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_root* inc_zebu_root(struct zebu_root* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_token_rule* inc_zebu_token_rule(struct zebu_token_rule* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_within* inc_zebu_within(struct zebu_within* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* token);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_charset(struct zebu_charset* ptree);

extern void free_zebu_charset_high(struct zebu_charset_high* ptree);

extern void free_zebu_charset_inter(struct zebu_charset_inter* ptree);

extern void free_zebu_charset_prefix(struct zebu_charset_prefix* ptree);

extern void free_zebu_charset_range(struct zebu_charset_range* ptree);

extern void free_zebu_charset_union(struct zebu_charset_union* ptree);

extern void free_zebu_expression(struct zebu_expression* ptree);

extern void free_zebu_expression_additive(struct zebu_expression_additive* ptree);

extern void free_zebu_expression_highest(struct zebu_expression_highest* ptree);

extern void free_zebu_expression_multiplicative(struct zebu_expression_multiplicative* ptree);

extern void free_zebu_expression_prefix(struct zebu_expression_prefix* ptree);

extern void free_zebu_regex(struct zebu_regex* ptree);

extern void free_zebu_regex_concat(struct zebu_regex_concat* ptree);

extern void free_zebu_regex_high(struct zebu_regex_high* ptree);

extern void free_zebu_regex_suffix(struct zebu_regex_suffix* ptree);

extern void free_zebu_regex_union(struct zebu_regex_union* ptree);

extern void free_zebu_root(struct zebu_root* ptree);

extern void free_zebu_token_rule(struct zebu_token_rule* ptree);

extern void free_zebu_within(struct zebu_within* ptree);

void free_zebu_token(struct zebu_token* token)
{
	if (token && !--token->refcount)
	{
		free(token->data);
		free(token);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_root(ptree->root);
		free(ptree);
	}
}

void free_zebu_charset(struct zebu_charset* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_union(ptree->inner);
		free(ptree);
	}
}

void free_zebu_charset_high(struct zebu_charset_high* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_charset(ptree->inner);
		free(ptree);
	}
}

void free_zebu_charset_inter(struct zebu_charset_inter* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_range(ptree->inner);
		free_zebu_charset_inter(ptree->sub);
		free(ptree);
	}
}

void free_zebu_charset_prefix(struct zebu_charset_prefix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->emark);
		free_zebu_charset_high(ptree->inner);
		free(ptree);
	}
}

void free_zebu_charset_range(struct zebu_charset_range* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_prefix(ptree->left);
		free_zebu_charset_prefix(ptree->right);
		free(ptree);
	}
}

void free_zebu_charset_union(struct zebu_charset_union* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_inter(ptree->inner);
		free_zebu_charset_union(ptree->sub);
		free(ptree);
	}
}

void free_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression_additive(ptree->inner);
		free(ptree);
	}
}

void free_zebu_expression_additive(struct zebu_expression_additive* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->add);
		free_zebu_expression_multiplicative(ptree->inner);
		free_zebu_expression_additive(ptree->left);
		free_zebu_expression_multiplicative(ptree->right);
		free_zebu_token(ptree->sub);
		free(ptree);
	}
}

void free_zebu_expression_highest(struct zebu_expression_highest* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->binary);
		free_zebu_token(ptree->decimal);
		free_zebu_token(ptree->hexadecimal);
		free_zebu_expression(ptree->inner);
		free_zebu_token(ptree->octal);
		free(ptree);
	}
}

void free_zebu_expression_multiplicative(struct zebu_expression_multiplicative* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->div);
		free_zebu_expression_prefix(ptree->inner);
		free_zebu_expression_multiplicative(ptree->left);
		free_zebu_token(ptree->mul);
		free_zebu_expression_prefix(ptree->right);
		free(ptree);
	}
}

void free_zebu_expression_prefix(struct zebu_expression_prefix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression_highest(ptree->inner);
		free_zebu_token(ptree->negate);
		free(ptree);
	}
}

void free_zebu_regex(struct zebu_regex* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_union(ptree->inner);
		free(ptree);
	}
}

void free_zebu_regex_concat(struct zebu_regex_concat* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_suffix(ptree->inner);
		free_zebu_regex_concat(ptree->sub);
		free(ptree);
	}
}

void free_zebu_regex_high(struct zebu_regex_high* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_charset(ptree->charset);
		free_zebu_token(ptree->string);
		free_zebu_regex(ptree->sub);
		free(ptree);
	}
}

void free_zebu_regex_suffix(struct zebu_regex_suffix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->asterisk);
		free_zebu_regex_high(ptree->inner);
		free_zebu_token(ptree->plus);
		free_zebu_token(ptree->qmark);
		free(ptree);
	}
}

void free_zebu_regex_union(struct zebu_regex_union* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_concat(ptree->inner);
		free_zebu_regex_union(ptree->sub);
		free(ptree);
	}
}

void free_zebu_root(struct zebu_root* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->rules.n; i < n; i++)
			free_zebu_token_rule(ptree->rules.data[i]);
		free(ptree->rules.data);
		free(ptree);
	}
}

void free_zebu_token_rule(struct zebu_token_rule* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->delete);
		free_zebu_expression(ptree->insert);
		free_zebu_expression(ptree->match);
		free_zebu_regex(ptree->regex);
		free_zebu_expression(ptree->update);
		for (unsigned i = 0, n = ptree->withins.n; i < n; i++)
			free_zebu_within(ptree->withins.data[i]);
		free(ptree->withins.data);
		free(ptree);
	}
}

void free_zebu_within(struct zebu_within* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->percent);
		free_zebu_expression(ptree->points);
		free_zebu_expression_highest(ptree->tolerance);
		free(ptree);
	}
}



#define argv0 (program_invocation_name)

#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '/':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02hhX", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap, line; } lexer = {
		.line = 1,
	};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	void push_char(unsigned char c)
	{
		while (lexer.n + 1 >= lexer.cap)
		{
			lexer.cap = lexer.cap << 1 ?: 1;
			#ifdef ZEBU_DEBUG
			ddprintf("lexer.cap == %u\n", lexer.cap);
			#endif
			lexer.data = realloc(lexer.data, lexer.cap);
		}
		
		lexer.data[lexer.n++] = c;
	}
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		unsigned line = lexer.line;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				push_char(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++, lexer.line = line;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				
				if (c == '\n')
				{
					line++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: line: %u\n", line);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\", line: %u\n", i, lexer.data, line);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0, lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = line;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->data[i] = 0;
					token->len = i;
					t = b, td = token;
					
					lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (t)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0, line = lexer.line;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = lexer.line;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->data[f] = 0;
					token->len = f;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				if (i != 0)
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' when reading '%.*s' on line %u!\n", argv0, i, lexer.data, line);
					else
						fprintf(stderr, "%s: unexpected '%c' when reading '%.*s' on line %u!\n", argv0, c, i, lexer.data, line);
				}
				else
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' on line %u!\n", argv0, line);
					else
						fprintf(stderr, "%s: unexpected '%c' on line %u!\n", argv0, c, line);
				}
				exit(1);
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
case 7:
{
struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_root* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_root(value->root), value->root = inc_zebu_root(subgrammar);
free_zebu_root(subgrammar);
}
d = value, g = 32;
break;
}
case 64:
{
struct zebu_expression_additive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_multiplicative* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_multiplicative(value->right), value->right = inc_zebu_expression_multiplicative(subgrammar);
free_zebu_expression_multiplicative(subgrammar);
}
d = value, g = 30;
break;
}
case 67:
{
struct zebu_expression_multiplicative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_prefix* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_prefix(value->right), value->right = inc_zebu_expression_prefix(subgrammar);
free_zebu_expression_prefix(subgrammar);
}
d = value, g = 31;
break;
}
case 48:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 23;
break;
}
case 49:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 23;
break;
}
case 50:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 23;
break;
}
case 51:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 23;
break;
}
case 52:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_within* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
if (value->withins.n == value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + 1, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
value->withins.data[0] = inc_zebu_within(subgrammar), value->withins.n++;
free_zebu_within(subgrammar);
}
d = value, g = 23;
break;
}
case 46:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 23;
break;
}
case 47:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 23;
break;
}
case 58:
{
struct zebu_within* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression(value->points), value->points = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
d = value, g = 29;
break;
}
case 54:
{
struct zebu_expression_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_highest* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_highest(value->inner), value->inner = inc_zebu_expression_highest(subgrammar);
free_zebu_expression_highest(subgrammar);
}
d = value, g = 28;
break;
}
case 20:
{
struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
if (value->rules.n == value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + 1, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
value->rules.data[0] = inc_zebu_token_rule(subgrammar), value->rules.n++;
free_zebu_token_rule(subgrammar);
}
d = value, g = 14;
break;
}
case 25:
{
struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_root* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->rules.n)
{
while (value->rules.n + trie->rules.n > value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + trie->rules.n, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
for (unsigned i = 0, n = trie->rules.n; i < n; i++)
value->rules.data[i] = inc_zebu_token_rule(trie->rules.data[i]);
value->rules.n += trie->rules.n;
}
free_zebu_root(trie);
}
{
struct zebu_token_rule* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
if (value->rules.n == value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + 1, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
value->rules.data[0] = inc_zebu_token_rule(subgrammar), value->rules.n++;
free_zebu_token_rule(subgrammar);
}
d = value, g = 14;
break;
}
case 59:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression(value->insert), value->insert = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 18;
break;
}
case 60:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression(value->update), value->update = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 19;
break;
}
case 61:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression(value->match), value->match = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 20;
break;
}
case 62:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression(value->delete), value->delete = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 21;
break;
}
case 36:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 37:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 38:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 40:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 35:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 41:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_within* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
if (value->withins.n == value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + 1, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
value->withins.data[0] = inc_zebu_within(subgrammar), value->withins.n++;
free_zebu_within(subgrammar);
}
d = value, g = 15;
break;
}
case 39:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 22;
break;
}
case 14:
{
struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_charset_union* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_union(value->inner), value->inner = inc_zebu_charset_union(subgrammar);
free_zebu_charset_union(subgrammar);
}
d = value, g = 8;
break;
}
case 26:
{
struct zebu_charset_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset(value->inner), value->inner = inc_zebu_charset(subgrammar);
free_zebu_charset(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 9;
break;
}
case 9:
{
struct zebu_charset_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->character), value->character = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 9;
break;
}
case 13:
{
struct zebu_charset_inter* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_range(value->inner), value->inner = inc_zebu_charset_range(subgrammar);
free_zebu_charset_range(subgrammar);
}
d = value, g = 10;
break;
}
case 29:
{
struct zebu_charset_inter* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_charset_inter* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_inter(value->sub), value->sub = inc_zebu_charset_inter(subgrammar);
free_zebu_charset_inter(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_range(value->inner), value->inner = inc_zebu_charset_range(subgrammar);
free_zebu_charset_range(subgrammar);
}
d = value, g = 10;
break;
}
case 10:
{
struct zebu_charset_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_charset_high* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_high(value->inner), value->inner = inc_zebu_charset_high(subgrammar);
free_zebu_charset_high(subgrammar);
}
d = value, g = 11;
break;
}
case 22:
{
struct zebu_charset_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_charset_high* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_high(value->inner), value->inner = inc_zebu_charset_high(subgrammar);
free_zebu_charset_high(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->emark), value->emark = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 11;
break;
}
case 12:
{
struct zebu_charset_range* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_prefix(value->left), value->left = inc_zebu_charset_prefix(subgrammar);
free_zebu_charset_prefix(subgrammar);
}
d = value, g = 12;
break;
}
case 28:
{
struct zebu_charset_range* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_prefix(value->right), value->right = inc_zebu_charset_prefix(subgrammar);
free_zebu_charset_prefix(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_prefix(value->left), value->left = inc_zebu_charset_prefix(subgrammar);
free_zebu_charset_prefix(subgrammar);
}
d = value, g = 12;
break;
}
case 11:
{
struct zebu_charset_union* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_charset_inter* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_inter(value->inner), value->inner = inc_zebu_charset_inter(subgrammar);
free_zebu_charset_inter(subgrammar);
}
d = value, g = 13;
break;
}
case 27:
{
struct zebu_charset_union* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_charset_union* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_union(value->sub), value->sub = inc_zebu_charset_union(subgrammar);
free_zebu_charset_union(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_charset_inter* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset_inter(value->inner), value->inner = inc_zebu_charset_inter(subgrammar);
free_zebu_charset_inter(subgrammar);
}
d = value, g = 13;
break;
}
case 42:
{
struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_additive* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_additive(value->inner), value->inner = inc_zebu_expression_additive(subgrammar);
free_zebu_expression_additive(subgrammar);
}
d = value, g = 24;
break;
}
case 65:
{
struct zebu_expression_additive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_additive* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->add) { free_zebu_token(value->add); value->add = inc_zebu_token(trie->add); }
if (trie->inner) { free_zebu_expression_multiplicative(value->inner); value->inner = inc_zebu_expression_multiplicative(trie->inner); }
if (trie->left) { free_zebu_expression_additive(value->left); value->left = inc_zebu_expression_additive(trie->left); }
if (trie->right) { free_zebu_expression_multiplicative(value->right); value->right = inc_zebu_expression_multiplicative(trie->right); }
if (trie->sub) { free_zebu_token(value->sub); value->sub = inc_zebu_token(trie->sub); }
free_zebu_expression_additive(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->add), value->add = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_expression_additive* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_additive(value->left), value->left = inc_zebu_expression_additive(subgrammar);
free_zebu_expression_additive(subgrammar);
}
d = value, g = 25;
break;
}
case 44:
{
struct zebu_expression_additive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_multiplicative* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_multiplicative(value->inner), value->inner = inc_zebu_expression_multiplicative(subgrammar);
free_zebu_expression_multiplicative(subgrammar);
}
d = value, g = 25;
break;
}
case 63:
{
struct zebu_expression_additive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_additive* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->add) { free_zebu_token(value->add); value->add = inc_zebu_token(trie->add); }
if (trie->inner) { free_zebu_expression_multiplicative(value->inner); value->inner = inc_zebu_expression_multiplicative(trie->inner); }
if (trie->left) { free_zebu_expression_additive(value->left); value->left = inc_zebu_expression_additive(trie->left); }
if (trie->right) { free_zebu_expression_multiplicative(value->right); value->right = inc_zebu_expression_multiplicative(trie->right); }
if (trie->sub) { free_zebu_token(value->sub); value->sub = inc_zebu_token(trie->sub); }
free_zebu_expression_additive(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->sub), value->sub = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_expression_additive* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_additive(value->left), value->left = inc_zebu_expression_additive(subgrammar);
free_zebu_expression_additive(subgrammar);
}
d = value, g = 25;
break;
}
case 34:
{
struct zebu_expression_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->hexadecimal), value->hexadecimal = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 17;
break;
}
case 33:
{
struct zebu_expression_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->octal), value->octal = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 17;
break;
}
case 56:
{
struct zebu_expression_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression(value->inner), value->inner = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 17;
break;
}
case 32:
{
struct zebu_expression_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->binary), value->binary = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 17;
break;
}
case 31:
{
struct zebu_expression_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->decimal), value->decimal = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 17;
break;
}
case 68:
{
struct zebu_expression_multiplicative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_multiplicative* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->div) { free_zebu_token(value->div); value->div = inc_zebu_token(trie->div); }
if (trie->inner) { free_zebu_expression_prefix(value->inner); value->inner = inc_zebu_expression_prefix(trie->inner); }
if (trie->left) { free_zebu_expression_multiplicative(value->left); value->left = inc_zebu_expression_multiplicative(trie->left); }
if (trie->mul) { free_zebu_token(value->mul); value->mul = inc_zebu_token(trie->mul); }
if (trie->right) { free_zebu_expression_prefix(value->right); value->right = inc_zebu_expression_prefix(trie->right); }
free_zebu_expression_multiplicative(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->div), value->div = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_expression_multiplicative* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_multiplicative(value->left), value->left = inc_zebu_expression_multiplicative(subgrammar);
free_zebu_expression_multiplicative(subgrammar);
}
d = value, g = 26;
break;
}
case 66:
{
struct zebu_expression_multiplicative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_multiplicative* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->div) { free_zebu_token(value->div); value->div = inc_zebu_token(trie->div); }
if (trie->inner) { free_zebu_expression_prefix(value->inner); value->inner = inc_zebu_expression_prefix(trie->inner); }
if (trie->left) { free_zebu_expression_multiplicative(value->left); value->left = inc_zebu_expression_multiplicative(trie->left); }
if (trie->mul) { free_zebu_token(value->mul); value->mul = inc_zebu_token(trie->mul); }
if (trie->right) { free_zebu_expression_prefix(value->right); value->right = inc_zebu_expression_prefix(trie->right); }
free_zebu_expression_multiplicative(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->mul), value->mul = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_expression_multiplicative* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_multiplicative(value->left), value->left = inc_zebu_expression_multiplicative(subgrammar);
free_zebu_expression_multiplicative(subgrammar);
}
d = value, g = 26;
break;
}
case 45:
{
struct zebu_expression_multiplicative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_prefix* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_prefix(value->inner), value->inner = inc_zebu_expression_prefix(subgrammar);
free_zebu_expression_prefix(subgrammar);
}
d = value, g = 26;
break;
}
case 53:
{
struct zebu_expression_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_prefix* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->inner) { free_zebu_expression_highest(value->inner); value->inner = inc_zebu_expression_highest(trie->inner); }
if (trie->negate) { free_zebu_token(value->negate); value->negate = inc_zebu_token(trie->negate); }
free_zebu_expression_prefix(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->negate), value->negate = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 27;
break;
}
case 55:
{
struct zebu_expression_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_prefix* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->inner) { free_zebu_expression_highest(value->inner); value->inner = inc_zebu_expression_highest(trie->inner); }
if (trie->negate) { free_zebu_token(value->negate); value->negate = inc_zebu_token(trie->negate); }
free_zebu_expression_prefix(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 27;
break;
}
case 43:
{
struct zebu_expression_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_expression_highest* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_highest(value->inner), value->inner = inc_zebu_expression_highest(subgrammar);
free_zebu_expression_highest(subgrammar);
}
d = value, g = 27;
break;
}
case 6:
{
struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_regex_union* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_union(value->inner), value->inner = inc_zebu_regex_union(subgrammar);
free_zebu_regex_union(subgrammar);
}
d = value, g = 1;
break;
}
case 5:
{
struct zebu_regex_concat* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_regex_suffix* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_suffix(value->inner), value->inner = inc_zebu_regex_suffix(subgrammar);
free_zebu_regex_suffix(subgrammar);
}
d = value, g = 2;
break;
}
case 18:
{
struct zebu_regex_concat* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_regex_concat* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_concat(value->sub), value->sub = inc_zebu_regex_concat(subgrammar);
free_zebu_regex_concat(subgrammar);
}
{
struct zebu_regex_suffix* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_suffix(value->inner), value->inner = inc_zebu_regex_suffix(subgrammar);
free_zebu_regex_suffix(subgrammar);
}
d = value, g = 2;
break;
}
case 2:
{
struct zebu_regex_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->string), value->string = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 3;
break;
}
case 23:
{
struct zebu_regex_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
free_zebu_charset(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 3;
break;
}
case 21:
{
struct zebu_regex_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex(value->sub), value->sub = inc_zebu_regex(subgrammar);
free_zebu_regex(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 3;
break;
}
case 1:
{
struct zebu_regex_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->character), value->character = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 3;
break;
}
case 16:
{
struct zebu_regex_suffix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->asterisk), value->asterisk = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_regex_high* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_high(value->inner), value->inner = inc_zebu_regex_high(subgrammar);
free_zebu_regex_high(subgrammar);
}
d = value, g = 4;
break;
}
case 17:
{
struct zebu_regex_suffix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->plus), value->plus = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_regex_high* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_high(value->inner), value->inner = inc_zebu_regex_high(subgrammar);
free_zebu_regex_high(subgrammar);
}
d = value, g = 4;
break;
}
case 4:
{
struct zebu_regex_suffix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_regex_high* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_high(value->inner), value->inner = inc_zebu_regex_high(subgrammar);
free_zebu_regex_high(subgrammar);
}
d = value, g = 4;
break;
}
case 15:
{
struct zebu_regex_suffix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->qmark), value->qmark = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_regex_high* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_high(value->inner), value->inner = inc_zebu_regex_high(subgrammar);
free_zebu_regex_high(subgrammar);
}
d = value, g = 4;
break;
}
case 3:
{
struct zebu_regex_union* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_regex_concat* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_concat(value->inner), value->inner = inc_zebu_regex_concat(subgrammar);
free_zebu_regex_concat(subgrammar);
}
d = value, g = 5;
break;
}
case 24:
{
struct zebu_regex_union* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_regex_union* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_union(value->sub), value->sub = inc_zebu_regex_union(subgrammar);
free_zebu_regex_union(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_regex_concat* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex_concat(value->inner), value->inner = inc_zebu_regex_concat(subgrammar);
free_zebu_regex_concat(subgrammar);
}
d = value, g = 5;
break;
}
case 8:
{
struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
if (value->rules.n == value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + 1, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
value->rules.data[0] = inc_zebu_token_rule(subgrammar), value->rules.n++;
free_zebu_token_rule(subgrammar);
}
d = value, g = 6;
break;
}
case 19:
{
struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_root* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->rules.n)
{
while (value->rules.n + trie->rules.n > value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + trie->rules.n, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
for (unsigned i = 0, n = trie->rules.n; i < n; i++)
value->rules.data[i] = inc_zebu_token_rule(trie->rules.data[i]);
value->rules.n += trie->rules.n;
}
free_zebu_root(trie);
}
{
struct zebu_token_rule* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
if (value->rules.n == value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + 1, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
value->rules.data[0] = inc_zebu_token_rule(subgrammar), value->rules.n++;
free_zebu_token_rule(subgrammar);
}
d = value, g = 6;
break;
}
case 30:
{
struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
if (trie->withins.n)
{
while (value->withins.n + trie->withins.n > value->withins.cap)
{
value->withins.cap = value->withins.cap << 1 ?: 1;
value->withins.data = realloc(value->withins.data, sizeof(*value->withins.data) * value->withins.cap);
}
memmove(value->withins.data + trie->withins.n, value->withins.data, sizeof(*value->withins.data) * value->withins.n);
for (unsigned i = 0, n = trie->withins.n; i < n; i++)
value->withins.data[i] = inc_zebu_within(trie->withins.data[i]);
value->withins.n += trie->withins.n;
}
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
free_zebu_regex(subgrammar);
}
d = value, g = 7;
break;
}
case 69:
{
struct zebu_within* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_within* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->percent) { free_zebu_token(value->percent); value->percent = inc_zebu_token(trie->percent); }
if (trie->points) { free_zebu_expression(value->points); value->points = inc_zebu_expression(trie->points); }
if (trie->tolerance) { free_zebu_expression_highest(value->tolerance); value->tolerance = inc_zebu_expression_highest(trie->tolerance); }
free_zebu_within(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(value->percent), value->percent = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_expression_highest* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_highest(value->tolerance), value->tolerance = inc_zebu_expression_highest(subgrammar);
free_zebu_expression_highest(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 16;
break;
}
case 57:
{
struct zebu_within* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
#if ZEBU_LINE_NUMBERS
value->startline = -1;
value->endline = 0;
#endif
#if ZEBU_TREE_DEPTH
value->tree_depth = 0;
#endif
{
struct zebu_within* trie = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
#endif
if (trie->percent) { free_zebu_token(value->percent); value->percent = inc_zebu_token(trie->percent); }
if (trie->points) { free_zebu_expression(value->points); value->points = inc_zebu_expression(trie->points); }
if (trie->tolerance) { free_zebu_expression_highest(value->tolerance); value->tolerance = inc_zebu_expression_highest(trie->tolerance); }
free_zebu_within(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
{
struct zebu_expression_highest* subgrammar = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
#endif
free_zebu_expression_highest(value->tolerance), value->tolerance = inc_zebu_expression_highest(subgrammar);
free_zebu_expression_highest(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
#if ZEBU_LINE_NUMBERS
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
#endif
#if ZEBU_TREE_DEPTH
token->tree_depth = &value->tree_depth;
#endif
free_zebu_token(token);
}
d = value, g = 16;
break;
}
}
			
			if (g == 32)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			struct zebu_token* token = td;
			
			fprintf(stderr, "zebu: unexpected token '%.*s'!\n", token->len, token->data);
			
			exit(1);
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















