#include "zebu.h"

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[172][27] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[3][2] = 13,
	[3][3] = 14,
	[3][4] = 15,
	[3][5] = 16,
	[5][2] = 22,
	[5][3] = 23,
	[5][11] = 24,
	[6][10] = 31,
	[7][6] = 32,
	[8][7] = 33,
	[8][8] = 34,
	[8][9] = 35,
	[9][2] = 2,
	[9][3] = 3,
	[9][4] = 4,
	[9][5] = 5,
	[12][2] = 2,
	[12][3] = 3,
	[12][4] = 4,
	[12][5] = 5,
	[14][2] = 13,
	[14][3] = 14,
	[14][4] = 15,
	[14][5] = 16,
	[16][2] = 22,
	[16][3] = 23,
	[16][11] = 24,
	[17][13] = 41,
	[18][6] = 42,
	[19][7] = 43,
	[19][8] = 44,
	[19][9] = 45,
	[20][2] = 13,
	[20][3] = 14,
	[20][4] = 15,
	[20][5] = 16,
	[23][2] = 47,
	[23][3] = 48,
	[23][11] = 49,
	[24][2] = 22,
	[24][3] = 23,
	[25][16] = 57,
	[27][6] = 58,
	[28][14] = 59,
	[29][15] = 60,
	[31][17] = 61,
	[32][2] = 2,
	[32][3] = 3,
	[32][4] = 4,
	[32][5] = 5,
	[38][2] = 2,
	[38][3] = 3,
	[38][4] = 4,
	[38][5] = 5,
	[39][13] = 64,
	[40][16] = 65,
	[42][2] = 13,
	[42][3] = 14,
	[42][4] = 15,
	[42][5] = 16,
	[48][2] = 47,
	[48][3] = 48,
	[48][11] = 49,
	[49][2] = 47,
	[49][3] = 48,
	[50][13] = 69,
	[52][6] = 70,
	[53][14] = 71,
	[54][15] = 72,
	[58][2] = 22,
	[58][3] = 23,
	[58][11] = 24,
	[59][2] = 74,
	[59][3] = 75,
	[59][11] = 76,
	[60][2] = 22,
	[60][3] = 23,
	[60][11] = 24,
	[61][18] = 80,
	[61][19] = 81,
	[61][20] = 82,
	[61][21] = 83,
	[61][22] = 84,
	[67][13] = 86,
	[70][2] = 47,
	[70][3] = 48,
	[70][11] = 49,
	[71][2] = 88,
	[71][3] = 89,
	[71][11] = 90,
	[72][2] = 47,
	[72][3] = 48,
	[72][11] = 49,
	[75][2] = 47,
	[75][3] = 48,
	[75][11] = 49,
	[76][2] = 74,
	[76][3] = 75,
	[80][10] = 96,
	[81][10] = 98,
	[82][10] = 100,
	[83][10] = 102,
	[84][23] = 104,
	[89][2] = 47,
	[89][3] = 48,
	[89][11] = 49,
	[90][2] = 88,
	[90][3] = 89,
	[94][13] = 108,
	[96][3] = 109,
	[96][9] = 111,
	[96][14] = 110,
	[96][24] = 112,
	[98][3] = 109,
	[98][9] = 111,
	[98][14] = 110,
	[98][24] = 112,
	[100][3] = 109,
	[100][9] = 111,
	[100][14] = 110,
	[100][24] = 112,
	[102][3] = 109,
	[102][9] = 111,
	[102][14] = 110,
	[102][24] = 112,
	[106][13] = 121,
	[109][3] = 122,
	[109][9] = 124,
	[109][14] = 123,
	[109][24] = 125,
	[110][3] = 109,
	[110][24] = 112,
	[111][3] = 109,
	[111][24] = 112,
	[113][18] = 134,
	[113][19] = 135,
	[113][20] = 136,
	[113][21] = 137,
	[113][22] = 139,
	[113][26] = 138,
	[114][9] = 142,
	[114][14] = 141,
	[116][8] = 143,
	[116][25] = 144,
	[118][18] = 134,
	[118][19] = 135,
	[118][20] = 136,
	[118][21] = 137,
	[118][22] = 139,
	[118][26] = 138,
	[119][18] = 134,
	[119][19] = 135,
	[119][20] = 136,
	[119][21] = 137,
	[119][22] = 139,
	[119][26] = 138,
	[120][18] = 134,
	[120][19] = 135,
	[120][20] = 136,
	[120][21] = 137,
	[120][22] = 139,
	[120][26] = 138,
	[122][3] = 122,
	[122][9] = 124,
	[122][14] = 123,
	[122][24] = 125,
	[123][3] = 122,
	[123][24] = 125,
	[124][3] = 122,
	[124][24] = 125,
	[126][13] = 152,
	[127][9] = 154,
	[127][14] = 153,
	[129][8] = 155,
	[129][25] = 156,
	[134][10] = 96,
	[135][10] = 98,
	[136][10] = 100,
	[137][10] = 102,
	[138][18] = 80,
	[138][19] = 81,
	[138][20] = 82,
	[138][21] = 83,
	[138][22] = 84,
	[139][23] = 104,
	[141][3] = 109,
	[141][9] = 111,
	[141][14] = 110,
	[141][24] = 112,
	[142][3] = 109,
	[142][9] = 111,
	[142][14] = 110,
	[142][24] = 112,
	[143][3] = 109,
	[143][9] = 111,
	[143][14] = 110,
	[143][24] = 112,
	[144][3] = 109,
	[144][9] = 111,
	[144][14] = 110,
	[144][24] = 112,
	[148][13] = 169,
	[153][3] = 122,
	[153][9] = 124,
	[153][14] = 123,
	[153][24] = 125,
	[154][3] = 122,
	[154][9] = 124,
	[154][14] = 123,
	[154][24] = 125,
	[155][3] = 122,
	[155][9] = 124,
	[155][14] = 123,
	[155][24] = 125,
	[156][3] = 122,
	[156][9] = 124,
	[156][14] = 123,
	[156][24] = 125,
	[164][8] = 143,
	[164][25] = 144,
	[171][8] = 155,
	[171][25] = 156,
};


const unsigned zebu_reduces[176][27] = {
	[2][2] = 1,
	[2][3] = 1,
	[2][4] = 1,
	[2][5] = 1,
	[2][6] = 1,
	[2][7] = 1,
	[2][8] = 1,
	[2][9] = 1,
	[2][10] = 1,
	[4][2] = 2,
	[4][3] = 2,
	[4][4] = 2,
	[4][5] = 2,
	[4][6] = 2,
	[4][7] = 2,
	[4][8] = 2,
	[4][9] = 2,
	[4][10] = 2,
	[7][10] = 3,
	[8][2] = 4,
	[8][3] = 4,
	[8][4] = 4,
	[8][5] = 4,
	[8][6] = 4,
	[8][10] = 4,
	[9][6] = 5,
	[9][10] = 5,
	[10][10] = 6,
	[11][12] = 7,
	[12][12] = 8,
	[13][2] = 1,
	[13][3] = 1,
	[13][4] = 1,
	[13][5] = 1,
	[13][6] = 1,
	[13][7] = 1,
	[13][8] = 1,
	[13][9] = 1,
	[13][13] = 1,
	[15][2] = 2,
	[15][3] = 2,
	[15][4] = 2,
	[15][5] = 2,
	[15][6] = 2,
	[15][7] = 2,
	[15][8] = 2,
	[15][9] = 2,
	[15][13] = 2,
	[18][13] = 3,
	[19][2] = 4,
	[19][3] = 4,
	[19][4] = 4,
	[19][5] = 4,
	[19][6] = 4,
	[19][13] = 4,
	[20][6] = 5,
	[20][13] = 5,
	[21][13] = 6,
	[22][6] = 9,
	[22][14] = 9,
	[22][15] = 9,
	[22][16] = 9,
	[26][6] = 10,
	[26][14] = 10,
	[26][15] = 10,
	[26][16] = 10,
	[27][16] = 11,
	[28][6] = 12,
	[28][15] = 12,
	[28][16] = 12,
	[29][6] = 13,
	[29][16] = 13,
	[30][16] = 14,
	[33][2] = 15,
	[33][3] = 15,
	[33][4] = 15,
	[33][5] = 15,
	[33][6] = 15,
	[33][10] = 15,
	[34][2] = 16,
	[34][3] = 16,
	[34][4] = 16,
	[34][5] = 16,
	[34][6] = 16,
	[34][10] = 16,
	[35][2] = 17,
	[35][3] = 17,
	[35][4] = 17,
	[35][5] = 17,
	[35][6] = 17,
	[35][10] = 17,
	[36][6] = 18,
	[36][10] = 18,
	[37][12] = 19,
	[38][12] = 20,
	[41][2] = 21,
	[41][3] = 21,
	[41][4] = 21,
	[41][5] = 21,
	[41][6] = 21,
	[41][7] = 21,
	[41][8] = 21,
	[41][9] = 21,
	[41][10] = 21,
	[43][2] = 15,
	[43][3] = 15,
	[43][4] = 15,
	[43][5] = 15,
	[43][6] = 15,
	[43][13] = 15,
	[44][2] = 16,
	[44][3] = 16,
	[44][4] = 16,
	[44][5] = 16,
	[44][6] = 16,
	[44][13] = 16,
	[45][2] = 17,
	[45][3] = 17,
	[45][4] = 17,
	[45][5] = 17,
	[45][6] = 17,
	[45][13] = 17,
	[46][6] = 18,
	[46][13] = 18,
	[47][6] = 9,
	[47][13] = 9,
	[47][14] = 9,
	[47][15] = 9,
	[51][6] = 10,
	[51][13] = 10,
	[51][14] = 10,
	[51][15] = 10,
	[52][13] = 11,
	[53][6] = 12,
	[53][13] = 12,
	[53][15] = 12,
	[54][6] = 13,
	[54][13] = 13,
	[55][13] = 14,
	[56][6] = 22,
	[56][14] = 22,
	[56][15] = 22,
	[56][16] = 22,
	[57][2] = 23,
	[57][3] = 23,
	[57][4] = 23,
	[57][5] = 23,
	[57][6] = 23,
	[57][7] = 23,
	[57][8] = 23,
	[57][9] = 23,
	[57][10] = 23,
	[62][10] = 24,
	[63][12] = 25,
	[64][2] = 21,
	[64][3] = 21,
	[64][4] = 21,
	[64][5] = 21,
	[64][6] = 21,
	[64][7] = 21,
	[64][8] = 21,
	[64][9] = 21,
	[64][13] = 21,
	[65][2] = 23,
	[65][3] = 23,
	[65][4] = 23,
	[65][5] = 23,
	[65][6] = 23,
	[65][7] = 23,
	[65][8] = 23,
	[65][9] = 23,
	[65][13] = 23,
	[66][13] = 24,
	[68][6] = 22,
	[68][13] = 22,
	[68][14] = 22,
	[68][15] = 22,
	[69][6] = 26,
	[69][14] = 26,
	[69][15] = 26,
	[69][16] = 26,
	[73][16] = 27,
	[74][6] = 9,
	[74][15] = 9,
	[74][16] = 9,
	[77][6] = 10,
	[77][15] = 10,
	[77][16] = 10,
	[78][6] = 28,
	[78][15] = 28,
	[78][16] = 28,
	[79][6] = 29,
	[79][16] = 29,
	[85][2] = 30,
	[85][3] = 30,
	[85][4] = 30,
	[85][5] = 30,
	[85][12] = 30,
	[86][6] = 26,
	[86][13] = 26,
	[86][14] = 26,
	[86][15] = 26,
	[87][13] = 27,
	[88][6] = 9,
	[88][13] = 9,
	[88][15] = 9,
	[91][6] = 10,
	[91][13] = 10,
	[91][15] = 10,
	[92][6] = 28,
	[92][13] = 28,
	[92][15] = 28,
	[93][6] = 29,
	[93][13] = 29,
	[95][6] = 22,
	[95][15] = 22,
	[95][16] = 22,
	[97][2] = 31,
	[97][3] = 31,
	[97][4] = 31,
	[97][5] = 31,
	[97][12] = 31,
	[99][2] = 32,
	[99][3] = 32,
	[99][4] = 32,
	[99][5] = 32,
	[99][12] = 32,
	[101][2] = 33,
	[101][3] = 33,
	[101][4] = 33,
	[101][5] = 33,
	[101][12] = 33,
	[103][2] = 34,
	[103][3] = 34,
	[103][4] = 34,
	[103][5] = 34,
	[103][12] = 34,
	[104][2] = 35,
	[104][3] = 35,
	[104][4] = 35,
	[104][5] = 35,
	[104][12] = 35,
	[105][2] = 36,
	[105][3] = 36,
	[105][4] = 36,
	[105][5] = 36,
	[105][12] = 36,
	[107][6] = 22,
	[107][13] = 22,
	[107][15] = 22,
	[108][6] = 26,
	[108][15] = 26,
	[108][16] = 26,
	[112][8] = 37,
	[112][9] = 37,
	[112][14] = 37,
	[112][18] = 37,
	[112][19] = 37,
	[112][20] = 37,
	[112][21] = 37,
	[112][22] = 37,
	[112][25] = 37,
	[112][26] = 37,
	[114][18] = 38,
	[114][19] = 38,
	[114][20] = 38,
	[114][21] = 38,
	[114][22] = 38,
	[114][26] = 38,
	[115][8] = 39,
	[115][9] = 39,
	[115][14] = 39,
	[115][18] = 39,
	[115][19] = 39,
	[115][20] = 39,
	[115][21] = 39,
	[115][22] = 39,
	[115][25] = 39,
	[115][26] = 39,
	[116][9] = 40,
	[116][14] = 40,
	[116][18] = 40,
	[116][19] = 40,
	[116][20] = 40,
	[116][21] = 40,
	[116][22] = 40,
	[116][26] = 40,
	[117][8] = 41,
	[117][9] = 41,
	[117][14] = 41,
	[117][18] = 41,
	[117][19] = 41,
	[117][20] = 41,
	[117][21] = 41,
	[117][22] = 41,
	[117][25] = 41,
	[117][26] = 41,
	[121][6] = 26,
	[121][13] = 26,
	[121][15] = 26,
	[125][8] = 37,
	[125][9] = 37,
	[125][13] = 37,
	[125][14] = 37,
	[125][25] = 37,
	[127][13] = 38,
	[128][8] = 39,
	[128][9] = 39,
	[128][13] = 39,
	[128][14] = 39,
	[128][25] = 39,
	[129][9] = 40,
	[129][13] = 40,
	[129][14] = 40,
	[130][8] = 41,
	[130][9] = 41,
	[130][13] = 41,
	[130][14] = 41,
	[130][25] = 41,
	[131][8] = 42,
	[131][9] = 42,
	[131][14] = 42,
	[131][18] = 42,
	[131][19] = 42,
	[131][20] = 42,
	[131][21] = 42,
	[131][22] = 42,
	[131][25] = 42,
	[131][26] = 42,
	[132][8] = 43,
	[132][9] = 43,
	[132][14] = 43,
	[132][18] = 43,
	[132][19] = 43,
	[132][20] = 43,
	[132][21] = 43,
	[132][22] = 43,
	[132][25] = 43,
	[132][26] = 43,
	[133][8] = 44,
	[133][9] = 44,
	[133][14] = 44,
	[133][18] = 44,
	[133][19] = 44,
	[133][20] = 44,
	[133][21] = 44,
	[133][22] = 44,
	[133][25] = 44,
	[133][26] = 44,
	[140][2] = 45,
	[140][3] = 45,
	[140][4] = 45,
	[140][5] = 45,
	[140][12] = 45,
	[145][2] = 46,
	[145][3] = 46,
	[145][4] = 46,
	[145][5] = 46,
	[145][12] = 46,
	[146][2] = 47,
	[146][3] = 47,
	[146][4] = 47,
	[146][5] = 47,
	[146][12] = 47,
	[147][2] = 48,
	[147][3] = 48,
	[147][4] = 48,
	[147][5] = 48,
	[147][12] = 48,
	[149][8] = 42,
	[149][9] = 42,
	[149][13] = 42,
	[149][14] = 42,
	[149][25] = 42,
	[150][8] = 43,
	[150][9] = 43,
	[150][13] = 43,
	[150][14] = 43,
	[150][25] = 43,
	[151][8] = 44,
	[151][9] = 44,
	[151][13] = 44,
	[151][14] = 44,
	[151][25] = 44,
	[152][8] = 49,
	[152][9] = 49,
	[152][14] = 49,
	[152][18] = 49,
	[152][19] = 49,
	[152][20] = 49,
	[152][21] = 49,
	[152][22] = 49,
	[152][25] = 49,
	[152][26] = 49,
	[157][2] = 50,
	[157][3] = 50,
	[157][4] = 50,
	[157][5] = 50,
	[157][12] = 50,
	[158][2] = 51,
	[158][3] = 51,
	[158][4] = 51,
	[158][5] = 51,
	[158][12] = 51,
	[159][2] = 52,
	[159][3] = 52,
	[159][4] = 52,
	[159][5] = 52,
	[159][12] = 52,
	[160][2] = 53,
	[160][3] = 53,
	[160][4] = 53,
	[160][5] = 53,
	[160][12] = 53,
	[161][2] = 54,
	[161][3] = 54,
	[161][4] = 54,
	[161][5] = 54,
	[161][12] = 54,
	[162][2] = 55,
	[162][3] = 55,
	[162][4] = 55,
	[162][5] = 55,
	[162][12] = 55,
	[163][9] = 56,
	[163][14] = 56,
	[163][18] = 56,
	[163][19] = 56,
	[163][20] = 56,
	[163][21] = 56,
	[163][22] = 56,
	[163][26] = 56,
	[164][9] = 57,
	[164][14] = 57,
	[164][18] = 57,
	[164][19] = 57,
	[164][20] = 57,
	[164][21] = 57,
	[164][22] = 57,
	[164][26] = 57,
	[165][9] = 58,
	[165][14] = 58,
	[165][18] = 58,
	[165][19] = 58,
	[165][20] = 58,
	[165][21] = 58,
	[165][22] = 58,
	[165][26] = 58,
	[166][8] = 59,
	[166][9] = 59,
	[166][14] = 59,
	[166][18] = 59,
	[166][19] = 59,
	[166][20] = 59,
	[166][21] = 59,
	[166][22] = 59,
	[166][25] = 59,
	[166][26] = 59,
	[167][8] = 60,
	[167][9] = 60,
	[167][14] = 60,
	[167][18] = 60,
	[167][19] = 60,
	[167][20] = 60,
	[167][21] = 60,
	[167][22] = 60,
	[167][25] = 60,
	[167][26] = 60,
	[168][8] = 61,
	[168][9] = 61,
	[168][14] = 61,
	[168][18] = 61,
	[168][19] = 61,
	[168][20] = 61,
	[168][21] = 61,
	[168][22] = 61,
	[168][25] = 61,
	[168][26] = 61,
	[169][8] = 49,
	[169][9] = 49,
	[169][13] = 49,
	[169][14] = 49,
	[169][25] = 49,
	[170][9] = 56,
	[170][13] = 56,
	[170][14] = 56,
	[171][9] = 57,
	[171][13] = 57,
	[171][14] = 57,
	[172][9] = 58,
	[172][13] = 58,
	[172][14] = 58,
	[173][8] = 59,
	[173][9] = 59,
	[173][13] = 59,
	[173][14] = 59,
	[173][25] = 59,
	[174][8] = 60,
	[174][9] = 60,
	[174][13] = 60,
	[174][14] = 60,
	[174][25] = 60,
	[175][8] = 61,
	[175][9] = 61,
	[175][13] = 61,
	[175][14] = 61,
	[175][25] = 61,
};


const unsigned zebu_gotos[157][30] = {
	[1][1] = 6,
	[1][2] = 7,
	[1][3] = 8,
	[1][4] = 9,
	[1][5] = 10,
	[1][6] = 11,
	[1][7] = 12,
	[3][1] = 17,
	[3][2] = 18,
	[3][3] = 19,
	[3][4] = 20,
	[3][5] = 21,
	[5][8] = 25,
	[5][9] = 26,
	[5][10] = 27,
	[5][11] = 28,
	[5][12] = 29,
	[5][13] = 30,
	[9][2] = 36,
	[9][3] = 8,
	[9][4] = 9,
	[12][1] = 6,
	[12][2] = 7,
	[12][3] = 8,
	[12][4] = 9,
	[12][5] = 10,
	[12][7] = 38,
	[12][14] = 37,
	[14][1] = 39,
	[14][2] = 18,
	[14][3] = 19,
	[14][4] = 20,
	[14][5] = 21,
	[16][8] = 40,
	[16][9] = 26,
	[16][10] = 27,
	[16][11] = 28,
	[16][12] = 29,
	[16][13] = 30,
	[20][2] = 46,
	[20][3] = 19,
	[20][4] = 20,
	[23][8] = 50,
	[23][9] = 51,
	[23][10] = 52,
	[23][11] = 53,
	[23][12] = 54,
	[23][13] = 55,
	[24][9] = 56,
	[32][2] = 7,
	[32][3] = 8,
	[32][4] = 9,
	[32][5] = 62,
	[38][1] = 6,
	[38][2] = 7,
	[38][3] = 8,
	[38][4] = 9,
	[38][5] = 10,
	[38][7] = 38,
	[38][14] = 63,
	[42][2] = 18,
	[42][3] = 19,
	[42][4] = 20,
	[42][5] = 66,
	[48][8] = 67,
	[48][9] = 51,
	[48][10] = 52,
	[48][11] = 53,
	[48][12] = 54,
	[48][13] = 55,
	[49][9] = 68,
	[58][9] = 26,
	[58][10] = 27,
	[58][11] = 28,
	[58][12] = 29,
	[58][13] = 73,
	[59][9] = 77,
	[59][11] = 78,
	[60][9] = 26,
	[60][10] = 79,
	[60][11] = 28,
	[60][12] = 29,
	[61][15] = 85,
	[70][9] = 51,
	[70][10] = 52,
	[70][11] = 53,
	[70][12] = 54,
	[70][13] = 87,
	[71][9] = 91,
	[71][11] = 92,
	[72][9] = 51,
	[72][10] = 93,
	[72][11] = 53,
	[72][12] = 54,
	[75][8] = 94,
	[75][9] = 51,
	[75][10] = 52,
	[75][11] = 53,
	[75][12] = 54,
	[75][13] = 55,
	[76][9] = 95,
	[80][16] = 97,
	[81][17] = 99,
	[82][18] = 101,
	[83][19] = 103,
	[84][20] = 105,
	[89][8] = 106,
	[89][9] = 51,
	[89][10] = 52,
	[89][11] = 53,
	[89][12] = 54,
	[89][13] = 55,
	[90][9] = 107,
	[96][21] = 113,
	[96][22] = 114,
	[96][23] = 115,
	[96][24] = 116,
	[96][25] = 117,
	[98][21] = 118,
	[98][22] = 114,
	[98][23] = 115,
	[98][24] = 116,
	[98][25] = 117,
	[100][21] = 119,
	[100][22] = 114,
	[100][23] = 115,
	[100][24] = 116,
	[100][25] = 117,
	[102][21] = 120,
	[102][22] = 114,
	[102][23] = 115,
	[102][24] = 116,
	[102][25] = 117,
	[109][21] = 126,
	[109][22] = 127,
	[109][23] = 128,
	[109][24] = 129,
	[109][25] = 130,
	[110][23] = 132,
	[110][26] = 131,
	[111][23] = 132,
	[111][26] = 133,
	[113][27] = 140,
	[118][27] = 145,
	[119][27] = 146,
	[120][27] = 147,
	[122][21] = 148,
	[122][22] = 127,
	[122][23] = 128,
	[122][24] = 129,
	[122][25] = 130,
	[123][23] = 150,
	[123][26] = 149,
	[124][23] = 150,
	[124][26] = 151,
	[134][16] = 157,
	[135][17] = 158,
	[136][18] = 159,
	[137][19] = 160,
	[138][15] = 161,
	[139][20] = 162,
	[141][23] = 115,
	[141][24] = 164,
	[141][25] = 117,
	[141][28] = 163,
	[142][23] = 115,
	[142][24] = 164,
	[142][25] = 117,
	[142][28] = 165,
	[143][23] = 115,
	[143][25] = 167,
	[143][29] = 166,
	[144][23] = 115,
	[144][25] = 167,
	[144][29] = 168,
	[153][23] = 128,
	[153][24] = 171,
	[153][25] = 130,
	[153][28] = 170,
	[154][23] = 128,
	[154][24] = 171,
	[154][25] = 130,
	[154][28] = 172,
	[155][23] = 128,
	[155][25] = 174,
	[155][29] = 173,
	[156][23] = 128,
	[156][25] = 174,
	[156][29] = 175,
};


const unsigned zebu_lexer[80][256] = {
	[1][9] = 30,
	[1][10] = 30,
	[1][32] = 30,
	[1][34] = 31,
	[1][39] = 32,
	[1][40] = 33,
	[1][47] = 34,
	[1][91] = 35,
	[2][9] = 30,
	[2][10] = 30,
	[2][32] = 30,
	[2][34] = 31,
	[2][39] = 32,
	[2][40] = 33,
	[2][42] = 36,
	[2][43] = 37,
	[2][47] = 34,
	[2][58] = 38,
	[2][63] = 39,
	[2][91] = 35,
	[2][124] = 40,
	[3][9] = 30,
	[3][10] = 30,
	[3][32] = 30,
	[3][33] = 41,
	[3][39] = 32,
	[3][40] = 33,
	[3][47] = 34,
	[4][9] = 30,
	[4][10] = 30,
	[4][32] = 30,
	[4][47] = 34,
	[4][58] = 38,
	[5][9] = 30,
	[5][10] = 30,
	[5][32] = 30,
	[5][47] = 34,
	[5][58] = 38,
	[5][124] = 40,
	[6][9] = 30,
	[6][10] = 30,
	[6][32] = 30,
	[6][34] = 31,
	[6][39] = 32,
	[6][40] = 33,
	[6][47] = 34,
	[6][58] = 38,
	[6][91] = 35,
	[6][124] = 40,
	[7][9] = 30,
	[7][10] = 30,
	[7][32] = 30,
	[7][47] = 34,
	[8][9] = 30,
	[8][10] = 30,
	[8][32] = 30,
	[8][34] = 31,
	[8][39] = 32,
	[8][40] = 33,
	[8][47] = 34,
	[8][91] = 35,
	[9][9] = 30,
	[9][10] = 30,
	[9][32] = 30,
	[9][34] = 31,
	[9][39] = 32,
	[9][40] = 33,
	[9][41] = 43,
	[9][42] = 36,
	[9][43] = 37,
	[9][47] = 34,
	[9][63] = 39,
	[9][91] = 35,
	[9][124] = 40,
	[10][9] = 30,
	[10][10] = 30,
	[10][32] = 30,
	[10][41] = 43,
	[10][47] = 34,
	[11][9] = 30,
	[11][10] = 30,
	[11][32] = 30,
	[11][41] = 43,
	[11][47] = 34,
	[11][124] = 40,
	[12][9] = 30,
	[12][10] = 30,
	[12][32] = 30,
	[12][34] = 31,
	[12][39] = 32,
	[12][40] = 33,
	[12][41] = 43,
	[12][47] = 34,
	[12][91] = 35,
	[12][124] = 40,
	[13][9] = 30,
	[13][10] = 30,
	[13][32] = 30,
	[13][38] = 44,
	[13][45] = 45,
	[13][47] = 34,
	[13][93] = 46,
	[13][124] = 40,
	[14][9] = 30,
	[14][10] = 30,
	[14][32] = 30,
	[14][39] = 32,
	[14][40] = 33,
	[14][47] = 34,
	[15][9] = 30,
	[15][10] = 30,
	[15][32] = 30,
	[15][47] = 34,
	[15][93] = 46,
	[16][9] = 30,
	[16][10] = 30,
	[16][32] = 30,
	[16][47] = 34,
	[16][93] = 46,
	[16][124] = 40,
	[17][9] = 30,
	[17][10] = 30,
	[17][32] = 30,
	[17][38] = 44,
	[17][47] = 34,
	[17][93] = 46,
	[17][124] = 40,
	[18][9] = 30,
	[18][10] = 30,
	[18][32] = 30,
	[18][47] = 34,
	[18][123] = 47,
	[19][9] = 30,
	[19][10] = 30,
	[19][32] = 30,
	[19][38] = 44,
	[19][41] = 43,
	[19][45] = 45,
	[19][47] = 34,
	[19][124] = 40,
	[20][9] = 30,
	[20][10] = 30,
	[20][32] = 30,
	[20][38] = 44,
	[20][41] = 43,
	[20][47] = 34,
	[20][124] = 40,
	[21][9] = 30,
	[21][10] = 30,
	[21][32] = 30,
	[21][47] = 34,
	[21][100] = 48,
	[21][105] = 49,
	[21][109] = 50,
	[21][117] = 51,
	[21][125] = 52,
	[22][9] = 30,
	[22][10] = 30,
	[22][32] = 30,
	[22][47] = 34,
	[22][59] = 53,
	[23][9] = 30,
	[23][10] = 30,
	[23][32] = 30,
	[23][40] = 33,
	[23][43] = 37,
	[23][45] = 45,
	[23][47] = 34,
	[23][48] = 54,
	[23][49] = 54,
	[23][50] = 54,
	[23][51] = 54,
	[23][52] = 54,
	[23][53] = 54,
	[23][54] = 54,
	[23][55] = 54,
	[23][56] = 54,
	[23][57] = 54,
	[24][9] = 30,
	[24][10] = 30,
	[24][32] = 30,
	[24][40] = 33,
	[24][47] = 34,
	[24][48] = 54,
	[24][49] = 54,
	[24][50] = 54,
	[24][51] = 54,
	[24][52] = 54,
	[24][53] = 54,
	[24][54] = 54,
	[24][55] = 54,
	[24][56] = 54,
	[24][57] = 54,
	[25][9] = 30,
	[25][10] = 30,
	[25][32] = 30,
	[25][42] = 36,
	[25][43] = 37,
	[25][44] = 55,
	[25][45] = 45,
	[25][47] = 56,
	[25][100] = 48,
	[25][105] = 49,
	[25][109] = 50,
	[25][117] = 51,
	[25][125] = 52,
	[26][9] = 30,
	[26][10] = 30,
	[26][32] = 30,
	[26][44] = 55,
	[26][47] = 34,
	[26][100] = 48,
	[26][105] = 49,
	[26][109] = 50,
	[26][117] = 51,
	[26][125] = 52,
	[27][9] = 30,
	[27][10] = 30,
	[27][32] = 30,
	[27][43] = 37,
	[27][44] = 55,
	[27][45] = 45,
	[27][47] = 34,
	[27][100] = 48,
	[27][105] = 49,
	[27][109] = 50,
	[27][117] = 51,
	[27][125] = 52,
	[28][9] = 30,
	[28][10] = 30,
	[28][32] = 30,
	[28][41] = 43,
	[28][42] = 36,
	[28][43] = 37,
	[28][45] = 45,
	[28][47] = 56,
	[29][9] = 30,
	[29][10] = 30,
	[29][32] = 30,
	[29][41] = 43,
	[29][43] = 37,
	[29][45] = 45,
	[29][47] = 34,
	[30][9] = 30,
	[30][10] = 30,
	[30][32] = 30,
	[30][47] = 34,
	[31][0] = 31,
	[31][1] = 31,
	[31][2] = 31,
	[31][3] = 31,
	[31][4] = 31,
	[31][5] = 31,
	[31][6] = 31,
	[31][7] = 31,
	[31][8] = 31,
	[31][9] = 31,
	[31][10] = 31,
	[31][11] = 31,
	[31][12] = 31,
	[31][13] = 31,
	[31][14] = 31,
	[31][15] = 31,
	[31][16] = 31,
	[31][17] = 31,
	[31][18] = 31,
	[31][19] = 31,
	[31][20] = 31,
	[31][21] = 31,
	[31][22] = 31,
	[31][23] = 31,
	[31][24] = 31,
	[31][25] = 31,
	[31][26] = 31,
	[31][27] = 31,
	[31][28] = 31,
	[31][29] = 31,
	[31][30] = 31,
	[31][31] = 31,
	[31][32] = 31,
	[31][33] = 31,
	[31][34] = 57,
	[31][35] = 31,
	[31][36] = 31,
	[31][37] = 31,
	[31][38] = 31,
	[31][39] = 31,
	[31][40] = 31,
	[31][41] = 31,
	[31][42] = 31,
	[31][43] = 31,
	[31][44] = 31,
	[31][45] = 31,
	[31][46] = 31,
	[31][47] = 31,
	[31][48] = 31,
	[31][49] = 31,
	[31][50] = 31,
	[31][51] = 31,
	[31][52] = 31,
	[31][53] = 31,
	[31][54] = 31,
	[31][55] = 31,
	[31][56] = 31,
	[31][57] = 31,
	[31][58] = 31,
	[31][59] = 31,
	[31][60] = 31,
	[31][61] = 31,
	[31][62] = 31,
	[31][63] = 31,
	[31][64] = 31,
	[31][65] = 31,
	[31][66] = 31,
	[31][67] = 31,
	[31][68] = 31,
	[31][69] = 31,
	[31][70] = 31,
	[31][71] = 31,
	[31][72] = 31,
	[31][73] = 31,
	[31][74] = 31,
	[31][75] = 31,
	[31][76] = 31,
	[31][77] = 31,
	[31][78] = 31,
	[31][79] = 31,
	[31][80] = 31,
	[31][81] = 31,
	[31][82] = 31,
	[31][83] = 31,
	[31][84] = 31,
	[31][85] = 31,
	[31][86] = 31,
	[31][87] = 31,
	[31][88] = 31,
	[31][89] = 31,
	[31][90] = 31,
	[31][91] = 31,
	[31][92] = 58,
	[31][93] = 31,
	[31][94] = 31,
	[31][95] = 31,
	[31][96] = 31,
	[31][97] = 31,
	[31][98] = 31,
	[31][99] = 31,
	[31][100] = 31,
	[31][101] = 31,
	[31][102] = 31,
	[31][103] = 31,
	[31][104] = 31,
	[31][105] = 31,
	[31][106] = 31,
	[31][107] = 31,
	[31][108] = 31,
	[31][109] = 31,
	[31][110] = 31,
	[31][111] = 31,
	[31][112] = 31,
	[31][113] = 31,
	[31][114] = 31,
	[31][115] = 31,
	[31][116] = 31,
	[31][117] = 31,
	[31][118] = 31,
	[31][119] = 31,
	[31][120] = 31,
	[31][121] = 31,
	[31][122] = 31,
	[31][123] = 31,
	[31][124] = 31,
	[31][125] = 31,
	[31][126] = 31,
	[31][127] = 31,
	[31][128] = 31,
	[31][129] = 31,
	[31][130] = 31,
	[31][131] = 31,
	[31][132] = 31,
	[31][133] = 31,
	[31][134] = 31,
	[31][135] = 31,
	[31][136] = 31,
	[31][137] = 31,
	[31][138] = 31,
	[31][139] = 31,
	[31][140] = 31,
	[31][141] = 31,
	[31][142] = 31,
	[31][143] = 31,
	[31][144] = 31,
	[31][145] = 31,
	[31][146] = 31,
	[31][147] = 31,
	[31][148] = 31,
	[31][149] = 31,
	[31][150] = 31,
	[31][151] = 31,
	[31][152] = 31,
	[31][153] = 31,
	[31][154] = 31,
	[31][155] = 31,
	[31][156] = 31,
	[31][157] = 31,
	[31][158] = 31,
	[31][159] = 31,
	[31][160] = 31,
	[31][161] = 31,
	[31][162] = 31,
	[31][163] = 31,
	[31][164] = 31,
	[31][165] = 31,
	[31][166] = 31,
	[31][167] = 31,
	[31][168] = 31,
	[31][169] = 31,
	[31][170] = 31,
	[31][171] = 31,
	[31][172] = 31,
	[31][173] = 31,
	[31][174] = 31,
	[31][175] = 31,
	[31][176] = 31,
	[31][177] = 31,
	[31][178] = 31,
	[31][179] = 31,
	[31][180] = 31,
	[31][181] = 31,
	[31][182] = 31,
	[31][183] = 31,
	[31][184] = 31,
	[31][185] = 31,
	[31][186] = 31,
	[31][187] = 31,
	[31][188] = 31,
	[31][189] = 31,
	[31][190] = 31,
	[31][191] = 31,
	[31][192] = 31,
	[31][193] = 31,
	[31][194] = 31,
	[31][195] = 31,
	[31][196] = 31,
	[31][197] = 31,
	[31][198] = 31,
	[31][199] = 31,
	[31][200] = 31,
	[31][201] = 31,
	[31][202] = 31,
	[31][203] = 31,
	[31][204] = 31,
	[31][205] = 31,
	[31][206] = 31,
	[31][207] = 31,
	[31][208] = 31,
	[31][209] = 31,
	[31][210] = 31,
	[31][211] = 31,
	[31][212] = 31,
	[31][213] = 31,
	[31][214] = 31,
	[31][215] = 31,
	[31][216] = 31,
	[31][217] = 31,
	[31][218] = 31,
	[31][219] = 31,
	[31][220] = 31,
	[31][221] = 31,
	[31][222] = 31,
	[31][223] = 31,
	[31][224] = 31,
	[31][225] = 31,
	[31][226] = 31,
	[31][227] = 31,
	[31][228] = 31,
	[31][229] = 31,
	[31][230] = 31,
	[31][231] = 31,
	[31][232] = 31,
	[31][233] = 31,
	[31][234] = 31,
	[31][235] = 31,
	[31][236] = 31,
	[31][237] = 31,
	[31][238] = 31,
	[31][239] = 31,
	[31][240] = 31,
	[31][241] = 31,
	[31][242] = 31,
	[31][243] = 31,
	[31][244] = 31,
	[31][245] = 31,
	[31][246] = 31,
	[31][247] = 31,
	[31][248] = 31,
	[31][249] = 31,
	[31][250] = 31,
	[31][251] = 31,
	[31][252] = 31,
	[31][253] = 31,
	[31][254] = 31,
	[31][255] = 31,
	[32][0] = 59,
	[32][1] = 59,
	[32][2] = 59,
	[32][3] = 59,
	[32][4] = 59,
	[32][5] = 59,
	[32][6] = 59,
	[32][7] = 59,
	[32][8] = 59,
	[32][9] = 59,
	[32][10] = 59,
	[32][11] = 59,
	[32][12] = 59,
	[32][13] = 59,
	[32][14] = 59,
	[32][15] = 59,
	[32][16] = 59,
	[32][17] = 59,
	[32][18] = 59,
	[32][19] = 59,
	[32][20] = 59,
	[32][21] = 59,
	[32][22] = 59,
	[32][23] = 59,
	[32][24] = 59,
	[32][25] = 59,
	[32][26] = 59,
	[32][27] = 59,
	[32][28] = 59,
	[32][29] = 59,
	[32][30] = 59,
	[32][31] = 59,
	[32][32] = 59,
	[32][33] = 59,
	[32][34] = 59,
	[32][35] = 59,
	[32][36] = 59,
	[32][37] = 59,
	[32][38] = 59,
	[32][40] = 59,
	[32][41] = 59,
	[32][42] = 59,
	[32][43] = 59,
	[32][44] = 59,
	[32][45] = 59,
	[32][46] = 59,
	[32][47] = 59,
	[32][48] = 59,
	[32][49] = 59,
	[32][50] = 59,
	[32][51] = 59,
	[32][52] = 59,
	[32][53] = 59,
	[32][54] = 59,
	[32][55] = 59,
	[32][56] = 59,
	[32][57] = 59,
	[32][58] = 59,
	[32][59] = 59,
	[32][60] = 59,
	[32][61] = 59,
	[32][62] = 59,
	[32][63] = 59,
	[32][64] = 59,
	[32][65] = 59,
	[32][66] = 59,
	[32][67] = 59,
	[32][68] = 59,
	[32][69] = 59,
	[32][70] = 59,
	[32][71] = 59,
	[32][72] = 59,
	[32][73] = 59,
	[32][74] = 59,
	[32][75] = 59,
	[32][76] = 59,
	[32][77] = 59,
	[32][78] = 59,
	[32][79] = 59,
	[32][80] = 59,
	[32][81] = 59,
	[32][82] = 59,
	[32][83] = 59,
	[32][84] = 59,
	[32][85] = 59,
	[32][86] = 59,
	[32][87] = 59,
	[32][88] = 59,
	[32][89] = 59,
	[32][90] = 59,
	[32][91] = 59,
	[32][92] = 60,
	[32][93] = 59,
	[32][94] = 59,
	[32][95] = 59,
	[32][96] = 59,
	[32][97] = 59,
	[32][98] = 59,
	[32][99] = 59,
	[32][100] = 59,
	[32][101] = 59,
	[32][102] = 59,
	[32][103] = 59,
	[32][104] = 59,
	[32][105] = 59,
	[32][106] = 59,
	[32][107] = 59,
	[32][108] = 59,
	[32][109] = 59,
	[32][110] = 59,
	[32][111] = 59,
	[32][112] = 59,
	[32][113] = 59,
	[32][114] = 59,
	[32][115] = 59,
	[32][116] = 59,
	[32][117] = 59,
	[32][118] = 59,
	[32][119] = 59,
	[32][120] = 59,
	[32][121] = 59,
	[32][122] = 59,
	[32][123] = 59,
	[32][124] = 59,
	[32][125] = 59,
	[32][126] = 59,
	[32][127] = 59,
	[32][128] = 59,
	[32][129] = 59,
	[32][130] = 59,
	[32][131] = 59,
	[32][132] = 59,
	[32][133] = 59,
	[32][134] = 59,
	[32][135] = 59,
	[32][136] = 59,
	[32][137] = 59,
	[32][138] = 59,
	[32][139] = 59,
	[32][140] = 59,
	[32][141] = 59,
	[32][142] = 59,
	[32][143] = 59,
	[32][144] = 59,
	[32][145] = 59,
	[32][146] = 59,
	[32][147] = 59,
	[32][148] = 59,
	[32][149] = 59,
	[32][150] = 59,
	[32][151] = 59,
	[32][152] = 59,
	[32][153] = 59,
	[32][154] = 59,
	[32][155] = 59,
	[32][156] = 59,
	[32][157] = 59,
	[32][158] = 59,
	[32][159] = 59,
	[32][160] = 59,
	[32][161] = 59,
	[32][162] = 59,
	[32][163] = 59,
	[32][164] = 59,
	[32][165] = 59,
	[32][166] = 59,
	[32][167] = 59,
	[32][168] = 59,
	[32][169] = 59,
	[32][170] = 59,
	[32][171] = 59,
	[32][172] = 59,
	[32][173] = 59,
	[32][174] = 59,
	[32][175] = 59,
	[32][176] = 59,
	[32][177] = 59,
	[32][178] = 59,
	[32][179] = 59,
	[32][180] = 59,
	[32][181] = 59,
	[32][182] = 59,
	[32][183] = 59,
	[32][184] = 59,
	[32][185] = 59,
	[32][186] = 59,
	[32][187] = 59,
	[32][188] = 59,
	[32][189] = 59,
	[32][190] = 59,
	[32][191] = 59,
	[32][192] = 59,
	[32][193] = 59,
	[32][194] = 59,
	[32][195] = 59,
	[32][196] = 59,
	[32][197] = 59,
	[32][198] = 59,
	[32][199] = 59,
	[32][200] = 59,
	[32][201] = 59,
	[32][202] = 59,
	[32][203] = 59,
	[32][204] = 59,
	[32][205] = 59,
	[32][206] = 59,
	[32][207] = 59,
	[32][208] = 59,
	[32][209] = 59,
	[32][210] = 59,
	[32][211] = 59,
	[32][212] = 59,
	[32][213] = 59,
	[32][214] = 59,
	[32][215] = 59,
	[32][216] = 59,
	[32][217] = 59,
	[32][218] = 59,
	[32][219] = 59,
	[32][220] = 59,
	[32][221] = 59,
	[32][222] = 59,
	[32][223] = 59,
	[32][224] = 59,
	[32][225] = 59,
	[32][226] = 59,
	[32][227] = 59,
	[32][228] = 59,
	[32][229] = 59,
	[32][230] = 59,
	[32][231] = 59,
	[32][232] = 59,
	[32][233] = 59,
	[32][234] = 59,
	[32][235] = 59,
	[32][236] = 59,
	[32][237] = 59,
	[32][238] = 59,
	[32][239] = 59,
	[32][240] = 59,
	[32][241] = 59,
	[32][242] = 59,
	[32][243] = 59,
	[32][244] = 59,
	[32][245] = 59,
	[32][246] = 59,
	[32][247] = 59,
	[32][248] = 59,
	[32][249] = 59,
	[32][250] = 59,
	[32][251] = 59,
	[32][252] = 59,
	[32][253] = 59,
	[32][254] = 59,
	[32][255] = 59,
	[34][47] = 61,
	[48][101] = 62,
	[49][110] = 63,
	[50][97] = 64,
	[51][112] = 65,
	[54][46] = 66,
	[54][48] = 54,
	[54][49] = 54,
	[54][50] = 54,
	[54][51] = 54,
	[54][52] = 54,
	[54][53] = 54,
	[54][54] = 54,
	[54][55] = 54,
	[54][56] = 54,
	[54][57] = 54,
	[56][47] = 61,
	[58][34] = 31,
	[58][110] = 31,
	[58][116] = 31,
	[59][39] = 67,
	[60][34] = 59,
	[60][110] = 59,
	[60][116] = 59,
	[61][0] = 61,
	[61][1] = 61,
	[61][2] = 61,
	[61][3] = 61,
	[61][4] = 61,
	[61][5] = 61,
	[61][6] = 61,
	[61][7] = 61,
	[61][8] = 61,
	[61][9] = 61,
	[61][10] = 30,
	[61][11] = 61,
	[61][12] = 61,
	[61][13] = 61,
	[61][14] = 61,
	[61][15] = 61,
	[61][16] = 61,
	[61][17] = 61,
	[61][18] = 61,
	[61][19] = 61,
	[61][20] = 61,
	[61][21] = 61,
	[61][22] = 61,
	[61][23] = 61,
	[61][24] = 61,
	[61][25] = 61,
	[61][26] = 61,
	[61][27] = 61,
	[61][28] = 61,
	[61][29] = 61,
	[61][30] = 61,
	[61][31] = 61,
	[61][32] = 61,
	[61][33] = 61,
	[61][34] = 61,
	[61][35] = 61,
	[61][36] = 61,
	[61][37] = 61,
	[61][38] = 61,
	[61][39] = 61,
	[61][40] = 61,
	[61][41] = 61,
	[61][42] = 61,
	[61][43] = 61,
	[61][44] = 61,
	[61][45] = 61,
	[61][46] = 61,
	[61][47] = 61,
	[61][48] = 61,
	[61][49] = 61,
	[61][50] = 61,
	[61][51] = 61,
	[61][52] = 61,
	[61][53] = 61,
	[61][54] = 61,
	[61][55] = 61,
	[61][56] = 61,
	[61][57] = 61,
	[61][58] = 61,
	[61][59] = 61,
	[61][60] = 61,
	[61][61] = 61,
	[61][62] = 61,
	[61][63] = 61,
	[61][64] = 61,
	[61][65] = 61,
	[61][66] = 61,
	[61][67] = 61,
	[61][68] = 61,
	[61][69] = 61,
	[61][70] = 61,
	[61][71] = 61,
	[61][72] = 61,
	[61][73] = 61,
	[61][74] = 61,
	[61][75] = 61,
	[61][76] = 61,
	[61][77] = 61,
	[61][78] = 61,
	[61][79] = 61,
	[61][80] = 61,
	[61][81] = 61,
	[61][82] = 61,
	[61][83] = 61,
	[61][84] = 61,
	[61][85] = 61,
	[61][86] = 61,
	[61][87] = 61,
	[61][88] = 61,
	[61][89] = 61,
	[61][90] = 61,
	[61][91] = 61,
	[61][92] = 61,
	[61][93] = 61,
	[61][94] = 61,
	[61][95] = 61,
	[61][96] = 61,
	[61][97] = 61,
	[61][98] = 61,
	[61][99] = 61,
	[61][100] = 61,
	[61][101] = 61,
	[61][102] = 61,
	[61][103] = 61,
	[61][104] = 61,
	[61][105] = 61,
	[61][106] = 61,
	[61][107] = 61,
	[61][108] = 61,
	[61][109] = 61,
	[61][110] = 61,
	[61][111] = 61,
	[61][112] = 61,
	[61][113] = 61,
	[61][114] = 61,
	[61][115] = 61,
	[61][116] = 61,
	[61][117] = 61,
	[61][118] = 61,
	[61][119] = 61,
	[61][120] = 61,
	[61][121] = 61,
	[61][122] = 61,
	[61][123] = 61,
	[61][124] = 61,
	[61][125] = 61,
	[61][126] = 61,
	[61][127] = 61,
	[61][128] = 61,
	[61][129] = 61,
	[61][130] = 61,
	[61][131] = 61,
	[61][132] = 61,
	[61][133] = 61,
	[61][134] = 61,
	[61][135] = 61,
	[61][136] = 61,
	[61][137] = 61,
	[61][138] = 61,
	[61][139] = 61,
	[61][140] = 61,
	[61][141] = 61,
	[61][142] = 61,
	[61][143] = 61,
	[61][144] = 61,
	[61][145] = 61,
	[61][146] = 61,
	[61][147] = 61,
	[61][148] = 61,
	[61][149] = 61,
	[61][150] = 61,
	[61][151] = 61,
	[61][152] = 61,
	[61][153] = 61,
	[61][154] = 61,
	[61][155] = 61,
	[61][156] = 61,
	[61][157] = 61,
	[61][158] = 61,
	[61][159] = 61,
	[61][160] = 61,
	[61][161] = 61,
	[61][162] = 61,
	[61][163] = 61,
	[61][164] = 61,
	[61][165] = 61,
	[61][166] = 61,
	[61][167] = 61,
	[61][168] = 61,
	[61][169] = 61,
	[61][170] = 61,
	[61][171] = 61,
	[61][172] = 61,
	[61][173] = 61,
	[61][174] = 61,
	[61][175] = 61,
	[61][176] = 61,
	[61][177] = 61,
	[61][178] = 61,
	[61][179] = 61,
	[61][180] = 61,
	[61][181] = 61,
	[61][182] = 61,
	[61][183] = 61,
	[61][184] = 61,
	[61][185] = 61,
	[61][186] = 61,
	[61][187] = 61,
	[61][188] = 61,
	[61][189] = 61,
	[61][190] = 61,
	[61][191] = 61,
	[61][192] = 61,
	[61][193] = 61,
	[61][194] = 61,
	[61][195] = 61,
	[61][196] = 61,
	[61][197] = 61,
	[61][198] = 61,
	[61][199] = 61,
	[61][200] = 61,
	[61][201] = 61,
	[61][202] = 61,
	[61][203] = 61,
	[61][204] = 61,
	[61][205] = 61,
	[61][206] = 61,
	[61][207] = 61,
	[61][208] = 61,
	[61][209] = 61,
	[61][210] = 61,
	[61][211] = 61,
	[61][212] = 61,
	[61][213] = 61,
	[61][214] = 61,
	[61][215] = 61,
	[61][216] = 61,
	[61][217] = 61,
	[61][218] = 61,
	[61][219] = 61,
	[61][220] = 61,
	[61][221] = 61,
	[61][222] = 61,
	[61][223] = 61,
	[61][224] = 61,
	[61][225] = 61,
	[61][226] = 61,
	[61][227] = 61,
	[61][228] = 61,
	[61][229] = 61,
	[61][230] = 61,
	[61][231] = 61,
	[61][232] = 61,
	[61][233] = 61,
	[61][234] = 61,
	[61][235] = 61,
	[61][236] = 61,
	[61][237] = 61,
	[61][238] = 61,
	[61][239] = 61,
	[61][240] = 61,
	[61][241] = 61,
	[61][242] = 61,
	[61][243] = 61,
	[61][244] = 61,
	[61][245] = 61,
	[61][246] = 61,
	[61][247] = 61,
	[61][248] = 61,
	[61][249] = 61,
	[61][250] = 61,
	[61][251] = 61,
	[61][252] = 61,
	[61][253] = 61,
	[61][254] = 61,
	[61][255] = 61,
	[62][108] = 68,
	[63][115] = 69,
	[64][116] = 70,
	[65][100] = 71,
	[66][48] = 66,
	[66][49] = 66,
	[66][50] = 66,
	[66][51] = 66,
	[66][52] = 66,
	[66][53] = 66,
	[66][54] = 66,
	[66][55] = 66,
	[66][56] = 66,
	[66][57] = 66,
	[68][101] = 72,
	[69][101] = 73,
	[70][99] = 74,
	[71][97] = 75,
	[72][116] = 76,
	[73][114] = 77,
	[74][104] = 78,
	[75][116] = 79,
	[76][101] = 80,
	[77][116] = 81,
	[79][101] = 82,
};


const unsigned zebu_lexer_starts[176] = {
	[1] = 1,
	[2] = 2,
	[3] = 1,
	[4] = 2,
	[5] = 3,
	[6] = 4,
	[7] = 5,
	[8] = 2,
	[9] = 6,
	[10] = 4,
	[11] = 7,
	[12] = 8,
	[13] = 9,
	[14] = 1,
	[15] = 9,
	[16] = 3,
	[17] = 10,
	[18] = 11,
	[19] = 9,
	[20] = 12,
	[21] = 10,
	[22] = 13,
	[23] = 3,
	[24] = 14,
	[25] = 15,
	[26] = 13,
	[27] = 16,
	[28] = 13,
	[29] = 17,
	[30] = 15,
	[31] = 18,
	[32] = 1,
	[33] = 6,
	[34] = 6,
	[35] = 6,
	[36] = 5,
	[37] = 7,
	[38] = 8,
	[39] = 10,
	[40] = 15,
	[41] = 2,
	[42] = 1,
	[43] = 12,
	[44] = 12,
	[45] = 12,
	[46] = 11,
	[47] = 19,
	[48] = 3,
	[49] = 14,
	[50] = 10,
	[51] = 19,
	[52] = 11,
	[53] = 19,
	[54] = 20,
	[55] = 10,
	[56] = 13,
	[57] = 2,
	[58] = 3,
	[59] = 3,
	[60] = 3,
	[61] = 21,
	[62] = 4,
	[63] = 7,
	[64] = 9,
	[65] = 9,
	[66] = 10,
	[67] = 10,
	[68] = 19,
	[69] = 13,
	[70] = 3,
	[71] = 3,
	[72] = 3,
	[73] = 15,
	[74] = 17,
	[75] = 3,
	[76] = 14,
	[77] = 17,
	[78] = 17,
	[79] = 16,
	[80] = 4,
	[81] = 4,
	[82] = 4,
	[83] = 4,
	[84] = 22,
	[85] = 8,
	[86] = 19,
	[87] = 10,
	[88] = 20,
	[89] = 3,
	[90] = 14,
	[91] = 20,
	[92] = 20,
	[93] = 11,
	[94] = 10,
	[95] = 17,
	[96] = 23,
	[97] = 8,
	[98] = 23,
	[99] = 8,
	[100] = 23,
	[101] = 8,
	[102] = 23,
	[103] = 8,
	[104] = 8,
	[105] = 8,
	[106] = 10,
	[107] = 20,
	[108] = 17,
	[109] = 23,
	[110] = 24,
	[111] = 24,
	[112] = 25,
	[113] = 26,
	[114] = 27,
	[115] = 25,
	[116] = 25,
	[117] = 25,
	[118] = 26,
	[119] = 26,
	[120] = 26,
	[121] = 20,
	[122] = 23,
	[123] = 24,
	[124] = 24,
	[125] = 28,
	[126] = 10,
	[127] = 29,
	[128] = 28,
	[129] = 28,
	[130] = 28,
	[131] = 25,
	[132] = 25,
	[133] = 25,
	[134] = 4,
	[135] = 4,
	[136] = 4,
	[137] = 4,
	[138] = 21,
	[139] = 22,
	[140] = 8,
	[141] = 23,
	[142] = 23,
	[143] = 23,
	[144] = 23,
	[145] = 8,
	[146] = 8,
	[147] = 8,
	[148] = 10,
	[149] = 28,
	[150] = 28,
	[151] = 28,
	[152] = 25,
	[153] = 23,
	[154] = 23,
	[155] = 23,
	[156] = 23,
	[157] = 8,
	[158] = 8,
	[159] = 8,
	[160] = 8,
	[161] = 8,
	[162] = 8,
	[163] = 27,
	[164] = 25,
	[165] = 27,
	[166] = 25,
	[167] = 25,
	[168] = 25,
	[169] = 28,
	[170] = 29,
	[171] = 28,
	[172] = 29,
	[173] = 28,
	[174] = 28,
	[175] = 28,
};


const unsigned zebu_lexer_accepts[83] = {
	[30] = 1,
	[33] = 3,
	[35] = 5,
	[36] = 8,
	[37] = 9,
	[38] = 10,
	[39] = 7,
	[40] = 6,
	[41] = 11,
	[42] = 12,
	[43] = 13,
	[44] = 15,
	[45] = 14,
	[46] = 16,
	[47] = 17,
	[52] = 22,
	[53] = 23,
	[54] = 24,
	[55] = 26,
	[56] = 25,
	[57] = 4,
	[66] = 24,
	[67] = 2,
	[78] = 19,
	[80] = 21,
	[81] = 18,
	[82] = 20,
};


const unsigned zebu_lexer_EOFs[9] = {
	[7] = 42,
	[8] = 42,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
	bool is_last;
	struct link* prev;
};

static void print_links(struct link* link)
{
	if (!link) return;
	
	print_links(link->prev);
	
	if (link->is_last)
		fputs("    ", stdout);
	else
		fputs("│   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '/':
		case '`':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}

enum prefix
{
	p_root,
	p_not_last_child,
	p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m\"", name);
	char escape[10];
	for (unsigned i = 0, n = token->len; i < n; i++)
		print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
	printf("\"\e[0m) on line %u\n", token->line);
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
	va_list ap;
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
	va_start(ap, format);
	vprintf(format, ap);
	va_end(ap);
	printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_charset(struct link* links, enum prefix p, const char* name, struct zebu_charset* ptree);

void print_zebu_charset_high(struct link* links, enum prefix p, const char* name, struct zebu_charset_high* ptree);

void print_zebu_charset_inter(struct link* links, enum prefix p, const char* name, struct zebu_charset_inter* ptree);

void print_zebu_charset_prefix(struct link* links, enum prefix p, const char* name, struct zebu_charset_prefix* ptree);

void print_zebu_charset_range(struct link* links, enum prefix p, const char* name, struct zebu_charset_range* ptree);

void print_zebu_charset_union(struct link* links, enum prefix p, const char* name, struct zebu_charset_union* ptree);

void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree);

void print_zebu_expression_additive(struct link* links, enum prefix p, const char* name, struct zebu_expression_additive* ptree);

void print_zebu_expression_highest(struct link* links, enum prefix p, const char* name, struct zebu_expression_highest* ptree);

void print_zebu_expression_multiplicative(struct link* links, enum prefix p, const char* name, struct zebu_expression_multiplicative* ptree);

void print_zebu_expression_prefix(struct link* links, enum prefix p, const char* name, struct zebu_expression_prefix* ptree);

void print_zebu_regex(struct link* links, enum prefix p, const char* name, struct zebu_regex* ptree);

void print_zebu_regex_concat(struct link* links, enum prefix p, const char* name, struct zebu_regex_concat* ptree);

void print_zebu_regex_high(struct link* links, enum prefix p, const char* name, struct zebu_regex_high* ptree);

void print_zebu_regex_suffix(struct link* links, enum prefix p, const char* name, struct zebu_regex_suffix* ptree);

void print_zebu_regex_union(struct link* links, enum prefix p, const char* name, struct zebu_regex_union* ptree);

void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree);

void print_zebu_token_rule(struct link* links, enum prefix p, const char* name, struct zebu_token_rule* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m$start\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->root)
		print_zebu_root(new ?: links, p_last_child, "root", ptree->root);
	else
		print_empty_leaf(new ?: links, p_last_child, "root", "root");
	free(new);
}
void print_zebu_charset(struct link* links, enum prefix p, const char* name, struct zebu_charset* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_charset_union(new ?: links, p_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset_union", "inner");
	free(new);
}
void print_zebu_charset_high(struct link* links, enum prefix p, const char* name, struct zebu_charset_high* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_high\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->character)
		print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
	if (ptree->inner)
		print_zebu_charset(new ?: links, p_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset", "inner");
	free(new);
}
void print_zebu_charset_inter(struct link* links, enum prefix p, const char* name, struct zebu_charset_inter* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_inter\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_charset_range(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_range", "inner");
	if (ptree->sub)
		print_zebu_charset_inter(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset_inter", "sub");
	free(new);
}
void print_zebu_charset_prefix(struct link* links, enum prefix p, const char* name, struct zebu_charset_prefix* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_prefix\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->emark)
		print_token_leaf(new ?: links, p_not_last_child, "emark", ptree->emark);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "emark");
	if (ptree->inner)
		print_zebu_charset_high(new ?: links, p_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset_high", "inner");
	free(new);
}
void print_zebu_charset_range(struct link* links, enum prefix p, const char* name, struct zebu_charset_range* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_range\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->left)
		print_zebu_charset_prefix(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_prefix", "left");
	if (ptree->right)
		print_zebu_charset_prefix(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset_prefix", "right");
	free(new);
}
void print_zebu_charset_union(struct link* links, enum prefix p, const char* name, struct zebu_charset_union* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_union\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_charset_inter(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_inter", "inner");
	if (ptree->sub)
		print_zebu_charset_union(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset_union", "sub");
	free(new);
}
void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_expression_additive(new ?: links, p_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression_additive", "inner");
	free(new);
}
void print_zebu_expression_additive(struct link* links, enum prefix p, const char* name, struct zebu_expression_additive* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression_additive\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->add)
		print_token_leaf(new ?: links, p_not_last_child, "add", ptree->add);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "add");
	if (ptree->inner)
		print_zebu_expression_multiplicative(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression_multiplicative", "inner");
	if (ptree->left)
		print_zebu_expression_additive(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression_additive", "left");
	if (ptree->right)
		print_zebu_expression_multiplicative(new ?: links, p_not_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression_multiplicative", "right");
	if (ptree->sub)
		print_token_leaf(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "sub");
	free(new);
}
void print_zebu_expression_highest(struct link* links, enum prefix p, const char* name, struct zebu_expression_highest* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression_highest\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "inner");
	if (ptree->literal)
		print_token_leaf(new ?: links, p_last_child, "literal", ptree->literal);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "literal");
	free(new);
}
void print_zebu_expression_multiplicative(struct link* links, enum prefix p, const char* name, struct zebu_expression_multiplicative* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression_multiplicative\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->div)
		print_token_leaf(new ?: links, p_not_last_child, "div", ptree->div);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "div");
	if (ptree->inner)
		print_zebu_expression_prefix(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression_prefix", "inner");
	if (ptree->left)
		print_zebu_expression_multiplicative(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression_multiplicative", "left");
	if (ptree->mul)
		print_token_leaf(new ?: links, p_not_last_child, "mul", ptree->mul);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "mul");
	if (ptree->right)
		print_zebu_expression_prefix(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression_prefix", "right");
	free(new);
}
void print_zebu_expression_prefix(struct link* links, enum prefix p, const char* name, struct zebu_expression_prefix* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression_prefix\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_expression_highest(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression_highest", "inner");
	if (ptree->negate)
		print_token_leaf(new ?: links, p_last_child, "negate", ptree->negate);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "negate");
	free(new);
}
void print_zebu_regex(struct link* links, enum prefix p, const char* name, struct zebu_regex* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_regex_union(new ?: links, p_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_last_child, "regex_union", "inner");
	free(new);
}
void print_zebu_regex_concat(struct link* links, enum prefix p, const char* name, struct zebu_regex_concat* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_concat\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_regex_suffix(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex_suffix", "inner");
	if (ptree->sub)
		print_zebu_regex_concat(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "regex_concat", "sub");
	free(new);
}
void print_zebu_regex_high(struct link* links, enum prefix p, const char* name, struct zebu_regex_high* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_high\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->character)
		print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
	if (ptree->charset)
		print_zebu_charset(new ?: links, p_not_last_child, "charset", ptree->charset);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset", "charset");
	if (ptree->string)
		print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
	if (ptree->sub)
		print_zebu_regex(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "regex", "sub");
	free(new);
}
void print_zebu_regex_suffix(struct link* links, enum prefix p, const char* name, struct zebu_regex_suffix* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_suffix\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->asterisk)
		print_token_leaf(new ?: links, p_not_last_child, "asterisk", ptree->asterisk);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "asterisk");
	if (ptree->inner)
		print_zebu_regex_high(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex_high", "inner");
	if (ptree->plus)
		print_token_leaf(new ?: links, p_not_last_child, "plus", ptree->plus);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "plus");
	if (ptree->qmark)
		print_token_leaf(new ?: links, p_last_child, "qmark", ptree->qmark);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "qmark");
	free(new);
}
void print_zebu_regex_union(struct link* links, enum prefix p, const char* name, struct zebu_regex_union* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_union\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_regex_concat(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex_concat", "inner");
	if (ptree->sub)
		print_zebu_regex_union(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "regex_union", "sub");
	free(new);
}
void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mroot\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->rules.n)
	{
		for (unsigned i = 0, n = ptree->rules.n; i < n; i++)
		{
			char label[5 + 30];
			snprintf(label, sizeof(label), "rules[%u]", i);
			print_zebu_token_rule(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->rules.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "token_rule[]", "rules");
	}
	free(new);
}
void print_zebu_token_rule(struct link* links, enum prefix p, const char* name, struct zebu_token_rule* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mtoken_rule\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->delete)
		print_zebu_expression(new ?: links, p_not_last_child, "delete", ptree->delete);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "delete");
	if (ptree->insert)
		print_zebu_expression(new ?: links, p_not_last_child, "insert", ptree->insert);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "insert");
	if (ptree->match)
		print_zebu_expression(new ?: links, p_not_last_child, "match", ptree->match);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "match");
	if (ptree->regex)
		print_zebu_regex(new ?: links, p_not_last_child, "regex", ptree->regex);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex", "regex");
	if (ptree->update)
		print_zebu_expression(new ?: links, p_last_child, "update", ptree->update);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "update");
	free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* token)
{
	if (token) token->refcount++;
	return token;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset* inc_zebu_charset(struct zebu_charset* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_high* inc_zebu_charset_high(struct zebu_charset_high* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_inter* inc_zebu_charset_inter(struct zebu_charset_inter* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_prefix* inc_zebu_charset_prefix(struct zebu_charset_prefix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_range* inc_zebu_charset_range(struct zebu_charset_range* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_union* inc_zebu_charset_union(struct zebu_charset_union* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression* inc_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression_additive* inc_zebu_expression_additive(struct zebu_expression_additive* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression_highest* inc_zebu_expression_highest(struct zebu_expression_highest* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression_multiplicative* inc_zebu_expression_multiplicative(struct zebu_expression_multiplicative* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression_prefix* inc_zebu_expression_prefix(struct zebu_expression_prefix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex* inc_zebu_regex(struct zebu_regex* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_concat* inc_zebu_regex_concat(struct zebu_regex_concat* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_high* inc_zebu_regex_high(struct zebu_regex_high* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_suffix* inc_zebu_regex_suffix(struct zebu_regex_suffix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_union* inc_zebu_regex_union(struct zebu_regex_union* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_root* inc_zebu_root(struct zebu_root* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_token_rule* inc_zebu_token_rule(struct zebu_token_rule* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* token);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_charset(struct zebu_charset* ptree);

extern void free_zebu_charset_high(struct zebu_charset_high* ptree);

extern void free_zebu_charset_inter(struct zebu_charset_inter* ptree);

extern void free_zebu_charset_prefix(struct zebu_charset_prefix* ptree);

extern void free_zebu_charset_range(struct zebu_charset_range* ptree);

extern void free_zebu_charset_union(struct zebu_charset_union* ptree);

extern void free_zebu_expression(struct zebu_expression* ptree);

extern void free_zebu_expression_additive(struct zebu_expression_additive* ptree);

extern void free_zebu_expression_highest(struct zebu_expression_highest* ptree);

extern void free_zebu_expression_multiplicative(struct zebu_expression_multiplicative* ptree);

extern void free_zebu_expression_prefix(struct zebu_expression_prefix* ptree);

extern void free_zebu_regex(struct zebu_regex* ptree);

extern void free_zebu_regex_concat(struct zebu_regex_concat* ptree);

extern void free_zebu_regex_high(struct zebu_regex_high* ptree);

extern void free_zebu_regex_suffix(struct zebu_regex_suffix* ptree);

extern void free_zebu_regex_union(struct zebu_regex_union* ptree);

extern void free_zebu_root(struct zebu_root* ptree);

extern void free_zebu_token_rule(struct zebu_token_rule* ptree);

void free_zebu_token(struct zebu_token* token)
{
	if (token && !--token->refcount)
	{
		free(token->data);
		free(token);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_root(ptree->root);
		free(ptree);
	}
}

void free_zebu_charset(struct zebu_charset* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_union(ptree->inner);
		free(ptree);
	}
}

void free_zebu_charset_high(struct zebu_charset_high* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_charset(ptree->inner);
		free(ptree);
	}
}

void free_zebu_charset_inter(struct zebu_charset_inter* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_range(ptree->inner);
		free_zebu_charset_inter(ptree->sub);
		free(ptree);
	}
}

void free_zebu_charset_prefix(struct zebu_charset_prefix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->emark);
		free_zebu_charset_high(ptree->inner);
		free(ptree);
	}
}

void free_zebu_charset_range(struct zebu_charset_range* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_prefix(ptree->left);
		free_zebu_charset_prefix(ptree->right);
		free(ptree);
	}
}

void free_zebu_charset_union(struct zebu_charset_union* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_inter(ptree->inner);
		free_zebu_charset_union(ptree->sub);
		free(ptree);
	}
}

void free_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression_additive(ptree->inner);
		free(ptree);
	}
}

void free_zebu_expression_additive(struct zebu_expression_additive* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->add);
		free_zebu_expression_multiplicative(ptree->inner);
		free_zebu_expression_additive(ptree->left);
		free_zebu_expression_multiplicative(ptree->right);
		free_zebu_token(ptree->sub);
		free(ptree);
	}
}

void free_zebu_expression_highest(struct zebu_expression_highest* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->inner);
		free_zebu_token(ptree->literal);
		free(ptree);
	}
}

void free_zebu_expression_multiplicative(struct zebu_expression_multiplicative* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->div);
		free_zebu_expression_prefix(ptree->inner);
		free_zebu_expression_multiplicative(ptree->left);
		free_zebu_token(ptree->mul);
		free_zebu_expression_prefix(ptree->right);
		free(ptree);
	}
}

void free_zebu_expression_prefix(struct zebu_expression_prefix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression_highest(ptree->inner);
		free_zebu_token(ptree->negate);
		free(ptree);
	}
}

void free_zebu_regex(struct zebu_regex* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_union(ptree->inner);
		free(ptree);
	}
}

void free_zebu_regex_concat(struct zebu_regex_concat* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_suffix(ptree->inner);
		free_zebu_regex_concat(ptree->sub);
		free(ptree);
	}
}

void free_zebu_regex_high(struct zebu_regex_high* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_charset(ptree->charset);
		free_zebu_token(ptree->string);
		free_zebu_regex(ptree->sub);
		free(ptree);
	}
}

void free_zebu_regex_suffix(struct zebu_regex_suffix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->asterisk);
		free_zebu_regex_high(ptree->inner);
		free_zebu_token(ptree->plus);
		free_zebu_token(ptree->qmark);
		free(ptree);
	}
}

void free_zebu_regex_union(struct zebu_regex_union* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_concat(ptree->inner);
		free_zebu_regex_union(ptree->sub);
		free(ptree);
	}
}

void free_zebu_root(struct zebu_root* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->rules.n; i < n; i++)
			free_zebu_token_rule(ptree->rules.data[i]);
		free(ptree->rules.data);
		free(ptree);
	}
}

void free_zebu_token_rule(struct zebu_token_rule* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->delete);
		free_zebu_expression(ptree->insert);
		free_zebu_expression(ptree->match);
		free_zebu_regex(ptree->regex);
		free_zebu_expression(ptree->update);
		free(ptree);
	}
}



#define argv0 (program_invocation_name)

#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '/':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02hhX", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap, line; } lexer = {
		.line = 1,
	};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	void push_char(unsigned char c)
	{
		while (lexer.n + 1 >= lexer.cap)
		{
			lexer.cap = lexer.cap << 1 ?: 1;
			#ifdef ZEBU_DEBUG
			ddprintf("lexer.cap == %u\n", lexer.cap);
			#endif
			lexer.data = realloc(lexer.data, lexer.cap);
		}
		
		lexer.data[lexer.n++] = c;
	}
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		unsigned line = lexer.line;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				push_char(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++, lexer.line = line;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				
				if (c == '\n')
				{
					line++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: line: %u\n", line);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\", line: %u\n", i, lexer.data, line);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0, lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = line;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->data[i] = 0;
					token->len = i;
					t = b, td = token;
					
					lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (t)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0, line = lexer.line;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = lexer.line;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->data[f] = 0;
					token->len = f;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				if (i != 0)
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' when reading '%.*s' on line %u!\n", argv0, i, lexer.data, line);
					else
						fprintf(stderr, "%s: unexpected '%c' when reading '%.*s' on line %u!\n", argv0, c, i, lexer.data, line);
				}
				else
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' on line %u!\n", argv0, line);
					else
						fprintf(stderr, "%s: unexpected '%c' on line %u!\n", argv0, c, line);
				}
				exit(1);
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
	case 7:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_root* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_root(value->root), value->root = inc_zebu_root(subgrammar);
free_zebu_root(subgrammar);
}
		d = value, g = 30;
		break;
	}
	case 57:
	{
		struct zebu_expression_additive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_multiplicative* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_multiplicative(value->right), value->right = inc_zebu_expression_multiplicative(subgrammar);
free_zebu_expression_multiplicative(subgrammar);
}
		d = value, g = 28;
		break;
	}
	case 60:
	{
		struct zebu_expression_multiplicative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_prefix* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_prefix(value->right), value->right = inc_zebu_expression_prefix(subgrammar);
free_zebu_expression_prefix(subgrammar);
}
		d = value, g = 29;
		break;
	}
	case 35:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 20;
		break;
	}
	case 43:
	{
		struct zebu_expression_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_highest* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_highest(value->inner), value->inner = inc_zebu_expression_highest(subgrammar);
free_zebu_expression_highest(subgrammar);
}
		d = value, g = 26;
		break;
	}
	case 20:
	{
		struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->rules.n == value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + 1, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
value->rules.data[0] = inc_zebu_token_rule(subgrammar), value->rules.n++;
free_zebu_token_rule(subgrammar);
}
		d = value, g = 14;
		break;
	}
	case 25:
	{
		struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_root* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->rules.n)
{
while (value->rules.n + trie->rules.n > value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + trie->rules.n, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
for (unsigned i = 0, n = trie->rules.n; i < n; i++)
value->rules.data[i] = inc_zebu_token_rule(trie->rules.data[i]);
value->rules.n += trie->rules.n;
}
free_zebu_root(trie);
}
{
struct zebu_token_rule* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->rules.n == value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + 1, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
value->rules.data[0] = inc_zebu_token_rule(subgrammar), value->rules.n++;
free_zebu_token_rule(subgrammar);
}
		d = value, g = 14;
		break;
	}
	case 50:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 27;
		break;
	}
	case 51:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 27;
		break;
	}
	case 52:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 27;
		break;
	}
	case 53:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 27;
		break;
	}
	case 54:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 27;
		break;
	}
	case 55:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 27;
		break;
	}
	case 45:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->insert), value->insert = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 16;
		break;
	}
	case 46:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->match), value->match = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 17;
		break;
	}
	case 47:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->update), value->update = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 18;
		break;
	}
	case 48:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->delete), value->delete = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 19;
		break;
	}
	case 31:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 15;
		break;
	}
	case 32:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 15;
		break;
	}
	case 33:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 15;
		break;
	}
	case 34:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 15;
		break;
	}
	case 36:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 15;
		break;
	}
	case 14:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_charset_union* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_union(value->inner), value->inner = inc_zebu_charset_union(subgrammar);
free_zebu_charset_union(subgrammar);
}
		d = value, g = 8;
		break;
	}
	case 26:
	{
		struct zebu_charset_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset(value->inner), value->inner = inc_zebu_charset(subgrammar);
free_zebu_charset(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 9;
		break;
	}
	case 9:
	{
		struct zebu_charset_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->character), value->character = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 9;
		break;
	}
	case 13:
	{
		struct zebu_charset_inter* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_range(value->inner), value->inner = inc_zebu_charset_range(subgrammar);
free_zebu_charset_range(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 29:
	{
		struct zebu_charset_inter* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_charset_inter* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_inter(value->sub), value->sub = inc_zebu_charset_inter(subgrammar);
free_zebu_charset_inter(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_range(value->inner), value->inner = inc_zebu_charset_range(subgrammar);
free_zebu_charset_range(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 10:
	{
		struct zebu_charset_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_charset_high* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_high(value->inner), value->inner = inc_zebu_charset_high(subgrammar);
free_zebu_charset_high(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 22:
	{
		struct zebu_charset_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_charset_high* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_high(value->inner), value->inner = inc_zebu_charset_high(subgrammar);
free_zebu_charset_high(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->emark), value->emark = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 11;
		break;
	}
	case 12:
	{
		struct zebu_charset_range* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_prefix(value->left), value->left = inc_zebu_charset_prefix(subgrammar);
free_zebu_charset_prefix(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 28:
	{
		struct zebu_charset_range* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_prefix(value->right), value->right = inc_zebu_charset_prefix(subgrammar);
free_zebu_charset_prefix(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_prefix(value->left), value->left = inc_zebu_charset_prefix(subgrammar);
free_zebu_charset_prefix(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 11:
	{
		struct zebu_charset_union* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_charset_inter* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_inter(value->inner), value->inner = inc_zebu_charset_inter(subgrammar);
free_zebu_charset_inter(subgrammar);
}
		d = value, g = 13;
		break;
	}
	case 27:
	{
		struct zebu_charset_union* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_charset_union* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_union(value->sub), value->sub = inc_zebu_charset_union(subgrammar);
free_zebu_charset_union(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_charset_inter* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset_inter(value->inner), value->inner = inc_zebu_charset_inter(subgrammar);
free_zebu_charset_inter(subgrammar);
}
		d = value, g = 13;
		break;
	}
	case 38:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_additive* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_additive(value->inner), value->inner = inc_zebu_expression_additive(subgrammar);
free_zebu_expression_additive(subgrammar);
}
		d = value, g = 21;
		break;
	}
	case 58:
	{
		struct zebu_expression_additive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_additive* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->add) { free_zebu_token(value->add); value->add = inc_zebu_token(trie->add); }
if (trie->inner) { free_zebu_expression_multiplicative(value->inner); value->inner = inc_zebu_expression_multiplicative(trie->inner); }
if (trie->left) { free_zebu_expression_additive(value->left); value->left = inc_zebu_expression_additive(trie->left); }
if (trie->right) { free_zebu_expression_multiplicative(value->right); value->right = inc_zebu_expression_multiplicative(trie->right); }
if (trie->sub) { free_zebu_token(value->sub); value->sub = inc_zebu_token(trie->sub); }
free_zebu_expression_additive(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->add), value->add = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_expression_additive* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_additive(value->left), value->left = inc_zebu_expression_additive(subgrammar);
free_zebu_expression_additive(subgrammar);
}
		d = value, g = 22;
		break;
	}
	case 40:
	{
		struct zebu_expression_additive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_multiplicative* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_multiplicative(value->inner), value->inner = inc_zebu_expression_multiplicative(subgrammar);
free_zebu_expression_multiplicative(subgrammar);
}
		d = value, g = 22;
		break;
	}
	case 56:
	{
		struct zebu_expression_additive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_additive* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->add) { free_zebu_token(value->add); value->add = inc_zebu_token(trie->add); }
if (trie->inner) { free_zebu_expression_multiplicative(value->inner); value->inner = inc_zebu_expression_multiplicative(trie->inner); }
if (trie->left) { free_zebu_expression_additive(value->left); value->left = inc_zebu_expression_additive(trie->left); }
if (trie->right) { free_zebu_expression_multiplicative(value->right); value->right = inc_zebu_expression_multiplicative(trie->right); }
if (trie->sub) { free_zebu_token(value->sub); value->sub = inc_zebu_token(trie->sub); }
free_zebu_expression_additive(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->sub), value->sub = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_expression_additive* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_additive(value->left), value->left = inc_zebu_expression_additive(subgrammar);
free_zebu_expression_additive(subgrammar);
}
		d = value, g = 22;
		break;
	}
	case 49:
	{
		struct zebu_expression_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->inner), value->inner = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 23;
		break;
	}
	case 37:
	{
		struct zebu_expression_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->literal), value->literal = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 23;
		break;
	}
	case 61:
	{
		struct zebu_expression_multiplicative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_multiplicative* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->div) { free_zebu_token(value->div); value->div = inc_zebu_token(trie->div); }
if (trie->inner) { free_zebu_expression_prefix(value->inner); value->inner = inc_zebu_expression_prefix(trie->inner); }
if (trie->left) { free_zebu_expression_multiplicative(value->left); value->left = inc_zebu_expression_multiplicative(trie->left); }
if (trie->mul) { free_zebu_token(value->mul); value->mul = inc_zebu_token(trie->mul); }
if (trie->right) { free_zebu_expression_prefix(value->right); value->right = inc_zebu_expression_prefix(trie->right); }
free_zebu_expression_multiplicative(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->div), value->div = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_expression_multiplicative* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_multiplicative(value->left), value->left = inc_zebu_expression_multiplicative(subgrammar);
free_zebu_expression_multiplicative(subgrammar);
}
		d = value, g = 24;
		break;
	}
	case 59:
	{
		struct zebu_expression_multiplicative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_multiplicative* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->div) { free_zebu_token(value->div); value->div = inc_zebu_token(trie->div); }
if (trie->inner) { free_zebu_expression_prefix(value->inner); value->inner = inc_zebu_expression_prefix(trie->inner); }
if (trie->left) { free_zebu_expression_multiplicative(value->left); value->left = inc_zebu_expression_multiplicative(trie->left); }
if (trie->mul) { free_zebu_token(value->mul); value->mul = inc_zebu_token(trie->mul); }
if (trie->right) { free_zebu_expression_prefix(value->right); value->right = inc_zebu_expression_prefix(trie->right); }
free_zebu_expression_multiplicative(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->mul), value->mul = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_expression_multiplicative* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_multiplicative(value->left), value->left = inc_zebu_expression_multiplicative(subgrammar);
free_zebu_expression_multiplicative(subgrammar);
}
		d = value, g = 24;
		break;
	}
	case 41:
	{
		struct zebu_expression_multiplicative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_prefix* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_prefix(value->inner), value->inner = inc_zebu_expression_prefix(subgrammar);
free_zebu_expression_prefix(subgrammar);
}
		d = value, g = 24;
		break;
	}
	case 42:
	{
		struct zebu_expression_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_prefix* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_expression_highest(value->inner); value->inner = inc_zebu_expression_highest(trie->inner); }
if (trie->negate) { free_zebu_token(value->negate); value->negate = inc_zebu_token(trie->negate); }
free_zebu_expression_prefix(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->negate), value->negate = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 25;
		break;
	}
	case 44:
	{
		struct zebu_expression_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_prefix* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_expression_highest(value->inner); value->inner = inc_zebu_expression_highest(trie->inner); }
if (trie->negate) { free_zebu_token(value->negate); value->negate = inc_zebu_token(trie->negate); }
free_zebu_expression_prefix(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 25;
		break;
	}
	case 39:
	{
		struct zebu_expression_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_expression_highest* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression_highest(value->inner), value->inner = inc_zebu_expression_highest(subgrammar);
free_zebu_expression_highest(subgrammar);
}
		d = value, g = 25;
		break;
	}
	case 6:
	{
		struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_regex_union* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_union(value->inner), value->inner = inc_zebu_regex_union(subgrammar);
free_zebu_regex_union(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 5:
	{
		struct zebu_regex_concat* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_regex_suffix* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_suffix(value->inner), value->inner = inc_zebu_regex_suffix(subgrammar);
free_zebu_regex_suffix(subgrammar);
}
		d = value, g = 2;
		break;
	}
	case 18:
	{
		struct zebu_regex_concat* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_regex_concat* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_concat(value->sub), value->sub = inc_zebu_regex_concat(subgrammar);
free_zebu_regex_concat(subgrammar);
}
{
struct zebu_regex_suffix* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_suffix(value->inner), value->inner = inc_zebu_regex_suffix(subgrammar);
free_zebu_regex_suffix(subgrammar);
}
		d = value, g = 2;
		break;
	}
	case 2:
	{
		struct zebu_regex_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->string), value->string = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 3;
		break;
	}
	case 1:
	{
		struct zebu_regex_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->character), value->character = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 3;
		break;
	}
	case 21:
	{
		struct zebu_regex_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex(value->sub), value->sub = inc_zebu_regex(subgrammar);
free_zebu_regex(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 3;
		break;
	}
	case 23:
	{
		struct zebu_regex_high* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
free_zebu_charset(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 3;
		break;
	}
	case 16:
	{
		struct zebu_regex_suffix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->asterisk), value->asterisk = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_regex_high* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_high(value->inner), value->inner = inc_zebu_regex_high(subgrammar);
free_zebu_regex_high(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 17:
	{
		struct zebu_regex_suffix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->plus), value->plus = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_regex_high* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_high(value->inner), value->inner = inc_zebu_regex_high(subgrammar);
free_zebu_regex_high(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 4:
	{
		struct zebu_regex_suffix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_regex_high* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_high(value->inner), value->inner = inc_zebu_regex_high(subgrammar);
free_zebu_regex_high(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 15:
	{
		struct zebu_regex_suffix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->qmark), value->qmark = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_regex_high* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_high(value->inner), value->inner = inc_zebu_regex_high(subgrammar);
free_zebu_regex_high(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 3:
	{
		struct zebu_regex_union* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_regex_concat* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_concat(value->inner), value->inner = inc_zebu_regex_concat(subgrammar);
free_zebu_regex_concat(subgrammar);
}
		d = value, g = 5;
		break;
	}
	case 24:
	{
		struct zebu_regex_union* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_regex_union* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_union(value->sub), value->sub = inc_zebu_regex_union(subgrammar);
free_zebu_regex_union(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_regex_concat* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex_concat(value->inner), value->inner = inc_zebu_regex_concat(subgrammar);
free_zebu_regex_concat(subgrammar);
}
		d = value, g = 5;
		break;
	}
	case 8:
	{
		struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->rules.n == value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + 1, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
value->rules.data[0] = inc_zebu_token_rule(subgrammar), value->rules.n++;
free_zebu_token_rule(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 19:
	{
		struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_root* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->rules.n)
{
while (value->rules.n + trie->rules.n > value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + trie->rules.n, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
for (unsigned i = 0, n = trie->rules.n; i < n; i++)
value->rules.data[i] = inc_zebu_token_rule(trie->rules.data[i]);
value->rules.n += trie->rules.n;
}
free_zebu_root(trie);
}
{
struct zebu_token_rule* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->rules.n == value->rules.cap)
{
value->rules.cap = value->rules.cap << 1 ?: 1;
value->rules.data = realloc(value->rules.data, sizeof(*value->rules.data) * value->rules.cap);
}
memmove(value->rules.data + 1, value->rules.data, sizeof(*value->rules.data) * value->rules.n);
value->rules.data[0] = inc_zebu_token_rule(subgrammar), value->rules.n++;
free_zebu_token_rule(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 30:
	{
		struct zebu_token_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token_rule* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->delete) { free_zebu_expression(value->delete); value->delete = inc_zebu_expression(trie->delete); }
if (trie->insert) { free_zebu_expression(value->insert); value->insert = inc_zebu_expression(trie->insert); }
if (trie->match) { free_zebu_expression(value->match); value->match = inc_zebu_expression(trie->match); }
if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
if (trie->update) { free_zebu_expression(value->update); value->update = inc_zebu_expression(trie->update); }
free_zebu_token_rule(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
free_zebu_regex(subgrammar);
}
		d = value, g = 7;
		break;
	}
}
			
			if (g == 30)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			struct zebu_token* token = td;
			
			fprintf(stderr, "zebu: unexpected token '%.*s'!\n", token->len, token->data);
			
			exit(1);
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















